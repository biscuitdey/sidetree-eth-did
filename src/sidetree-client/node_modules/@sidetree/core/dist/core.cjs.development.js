'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

function _interopNamespace(e) {
  if (e && e.__esModule) { return e; } else {
    var n = {};
    if (e) {
      Object.keys(e).forEach(function (k) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      });
    }
    n['default'] = e;
    return n;
  }
}

var common = require('@sidetree/common');
var jsonpatch = _interopDefault(require('fast-json-patch'));
var jose = require('jose');
var bip39 = require('bip39');
var didKeyEd25519 = require('@transmute/did-key-ed25519');
var hdkey = _interopDefault(require('hdkey'));
var keyto = require('@trust/keyto');
var didKeySecp256k1 = require('@transmute/did-key-secp256k1');
var timeSpan = _interopDefault(require('time-span'));
var crypto = require('crypto');
var db = require('@sidetree/db');
var PriorityQueue = _interopDefault(require('priorityqueue'));
var chalk = _interopDefault(require('chalk'));
var url = require('url');

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/main/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Class containing methods that operates against an array.
 */
var ArrayMethods = /*#__PURE__*/function () {
  function ArrayMethods() {}

  /**
   * Checkes to see if there are duplicates in the given array.
   */
  ArrayMethods.hasDuplicates = function hasDuplicates(array) {
    var uniqueValues = new Set();

    for (var i = 0; i < array.length; i++) {
      var value = array[i];

      if (uniqueValues.has(value)) {
        return true;
      }

      uniqueValues.add(value);
    }

    return false;
  }
  /**
   * Checks that entries in array 2 is not in array 1.
   */
  ;

  ArrayMethods.areMutuallyExclusive = function areMutuallyExclusive(array1, array2) {
    var valuesInArray1 = new Set(array1);

    for (var _iterator = _createForOfIteratorHelperLoose(array2), _step; !(_step = _iterator()).done;) {
      var value = _step.value;

      if (valuesInArray1.has(value)) {
        return false;
      }
    }

    return true;
  };

  return ArrayMethods;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/main/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var pako = /*#__PURE__*/require('pako');
/**
 * Encapsulates functionality to compress/decompress data.
 */


var Compressor = /*#__PURE__*/function () {
  function Compressor() {}

  /**
   * Compresses the data in gzip and return it as buffer.
   * @param inputAsBuffer The input string to be compressed.
   */
  Compressor.compress =
  /*#__PURE__*/
  function () {
    var _compress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(inputAsBuffer) {
      var result;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              result = pako.deflate(Buffer.from(inputAsBuffer));
              return _context.abrupt("return", Buffer.from(result));

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function compress(_x) {
      return _compress.apply(this, arguments);
    }

    return compress;
  }()
  /**
   * Decompresses the input and returns it as buffer.
   * @param inputAsBuffer The gzip compressed data.
   */
  ;

  Compressor.decompress =
  /*#__PURE__*/
  function () {
    var _decompress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(inputAsBuffer) {
      var result;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              result = pako.inflate(inputAsBuffer);
              return _context2.abrupt("return", Buffer.from(result));

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function decompress(_x2) {
      return _decompress.apply(this, arguments);
    }

    return decompress;
  }();

  return Compressor;
}();

/**
 * Class that handles the composition of operations into final external-facing document.
 */

var DocumentComposer = /*#__PURE__*/function () {
  function DocumentComposer() {}

  /**
   * Transforms the given DID state into a DID Document.
   */
  DocumentComposer.transformToExternalDocument = function transformToExternalDocument(didState, did) {
    // If the DID is deactivated.
    if (didState.nextRecoveryCommitmentHash === undefined) {
      return {
        status: 'deactivated'
      };
    }

    var document = didState.document;
    var shortFormDid = did.split('?')[0]; // Only populate `publicKey` if general purpose exists.
    // Only populate `authentication` if auth purpose exists.

    var authentication = [];
    var assertionMethod = [];
    var capabilityInvocation = [];
    var capabilityDelegation = [];
    var keyAgreement = [];
    var public_keys = [];

    if (Array.isArray(document.public_keys)) {
      for (var _iterator = _createForOfIteratorHelperLoose(document.public_keys), _step; !(_step = _iterator()).done;) {
        var publicKey = _step.value;
        var id = '#' + publicKey.id;
        var didDocumentPublicKey = {
          id: id,
          controller: shortFormDid,
          type: publicKey.type,
          publicKeyJwk: publicKey.jwk
        };
        var purposeSet = new Set(publicKey.purpose);

        if (purposeSet.has(common.PublicKeyPurpose.General)) {
          public_keys.push(didDocumentPublicKey);

          if (purposeSet.has(common.PublicKeyPurpose.Auth)) {
            authentication.push(id);
          }

          if (purposeSet.has(common.PublicKeyPurpose.AssertionMethod)) {
            assertionMethod.push(id);
          }

          if (purposeSet.has(common.PublicKeyPurpose.CapabilityInvocation)) {
            capabilityInvocation.push(id);
          }

          if (purposeSet.has(common.PublicKeyPurpose.CapabilityDelegation)) {
            capabilityDelegation.push(id);
          }

          if (purposeSet.has(common.PublicKeyPurpose.KeyAgreement)) {
            keyAgreement.push(id);
          }
        } else if (purposeSet.has(common.PublicKeyPurpose.Auth)) {
          authentication.push(didDocumentPublicKey);
        } else if (purposeSet.has(common.PublicKeyPurpose.AssertionMethod)) {
          assertionMethod.push(assertionMethod);
        } else if (purposeSet.has(common.PublicKeyPurpose.CapabilityInvocation)) {
          capabilityInvocation.push(didDocumentPublicKey);
        } else if (purposeSet.has(common.PublicKeyPurpose.CapabilityDelegation)) {
          capabilityDelegation.push(didDocumentPublicKey);
        } else if (purposeSet.has(common.PublicKeyPurpose.KeyAgreement)) {
          keyAgreement.push(didDocumentPublicKey);
        }
      }
    } // Only update `service_endpoints` if the array is present


    var service_endpoints = [];

    if (Array.isArray(document.service_endpoints)) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(document.service_endpoints), _step2; !(_step2 = _iterator2()).done;) {
        var serviceEndpoint = _step2.value;
        var didDocumentServiceEndpoint = {
          id: '#' + serviceEndpoint.id,
          type: serviceEndpoint.type,
          serviceEndpoint: serviceEndpoint.endpoint
        };
        service_endpoints.push(didDocumentServiceEndpoint);
      }
    }

    var didDocument = {
      id: shortFormDid,
      '@context': ['https://www.w3.org/ns/did/v1', 'https://ns.did.ai/transmute/v1', {
        '@base': shortFormDid
      }]
    };

    if (public_keys.length !== 0) {
      didDocument.publicKey = public_keys;
    }

    if (authentication.length !== 0) {
      didDocument.authentication = authentication;
    }

    if (assertionMethod.length !== 0) {
      didDocument.assertionMethod = assertionMethod;
    }

    if (capabilityInvocation.length !== 0) {
      didDocument.capabilityInvocation = capabilityInvocation;
    }

    if (capabilityDelegation.length !== 0) {
      didDocument.capabilityDelegation = capabilityDelegation;
    }

    if (keyAgreement.length !== 0) {
      didDocument.keyAgreement = keyAgreement;
    }

    if (service_endpoints.length !== 0) {
      didDocument.service = service_endpoints;
    }

    var didResolutionResult = {
      '@context': 'https://w3id.org/did-resolution/v1',
      didDocument: didDocument,
      didDocumentMetadata: {
        recoveryCommitment: didState.nextRecoveryCommitmentHash,
        updateCommitment: didState.nextUpdateCommitmentHash
      }
    };
    return JSON.parse(JSON.stringify(didResolutionResult));
  }
  /**
   * Applies the update operation to the given document.
   * @returns The resultant document.
   * @throws SidetreeError if invalid operation is given.
   */
  ;

  DocumentComposer.applyUpdateOperation =
  /*#__PURE__*/
  function () {
    var _applyUpdateOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(operation, document) {
      var resultantDocument;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              resultantDocument = DocumentComposer.applyPatches(document, operation.delta.patches);
              return _context.abrupt("return", resultantDocument);

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function applyUpdateOperation(_x, _x2) {
      return _applyUpdateOperation.apply(this, arguments);
    }

    return applyUpdateOperation;
  }()
  /**
   * Validates the schema of the given full document.
   * @throws SidetreeError if given document patch fails validation.
   */
  ;

  DocumentComposer.validateDocument = function validateDocument(document) {
    if (document === undefined) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerDocumentMissing);
    }

    var allowedProperties = new Set(['public_keys', 'service_endpoints']);

    for (var property in document) {
      if (!allowedProperties.has(property)) {
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerUnknownPropertyInDocument, "Unexpected property " + property + " in document.");
      }
    } // Verify 'public_keys' property if it exists.


    if (Object.prototype.hasOwnProperty.call(document, 'public_keys')) {
      DocumentComposer.validatePublicKeys(document.public_keys);
    } // Verify 'service_endpoints' property if it exists.


    if (Object.prototype.hasOwnProperty.call(document, 'service_endpoints')) {
      // Verify each endpoint entry in service_endpoints.
      DocumentComposer.validateServiceEndpoints(document.service_endpoints);
    }
  }
  /**
   * Validates the schema of the given update document patch.
   * @throws SidetreeError if given document patch fails validation.
   */
  ;

  DocumentComposer.validateDocumentPatches = function validateDocumentPatches(patches) {
    if (!Array.isArray(patches)) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerUpdateOperationDocumentPatchesNotArray);
    }

    for (var _iterator3 = _createForOfIteratorHelperLoose(patches), _step3; !(_step3 = _iterator3()).done;) {
      var patch = _step3.value;
      DocumentComposer.validatePatch(patch);
    }
  };

  DocumentComposer.validatePatch = function validatePatch(patch) {
    var action = patch.action;

    switch (action) {
      case 'replace':
        DocumentComposer.validateDocument(patch.document);
        break;

      case 'add-public-keys':
        DocumentComposer.validateAddPublicKeysPatch(patch);
        break;

      case 'remove-public-keys':
        DocumentComposer.validateRemovePublicKeysPatch(patch);
        break;

      case 'add-service-endpoints':
        DocumentComposer.validateAddServiceEndpointsPatch(patch);
        break;

      case 'remove-service-endpoints':
        DocumentComposer.validateRemoveServiceEndpointsPatch(patch);
        break;

      case 'ietf-json-patch':
        DocumentComposer.validateIetfJsonPatch(patch);
        break;

      default:
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchMissingOrUnknownAction);
    }
  };

  DocumentComposer.validateIetfJsonPatch = function validateIetfJsonPatch(patch) {
    var patchProperties = Object.keys(patch);

    if (patchProperties.length !== 2) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchMissingOrUnknownProperty);
    }

    var error = jsonpatch.validate(patch.patches);

    if (error) {
      console.warn(error);
      throw new common.SidetreeError(error.name);
    }
  };

  DocumentComposer.validateAddPublicKeysPatch = function validateAddPublicKeysPatch(patch) {
    var patchProperties = Object.keys(patch);

    if (patchProperties.length !== 2) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchMissingOrUnknownProperty);
    }

    DocumentComposer.validatePublicKeys(patch.public_keys);
  };

  DocumentComposer.validatePublicKeys = function validatePublicKeys(public_keys) {
    if (!Array.isArray(public_keys)) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerPublicKeysNotArray);
    }

    var publicKeyIdSet = new Set();

    for (var _iterator4 = _createForOfIteratorHelperLoose(public_keys), _step4; !(_step4 = _iterator4()).done;) {
      var publicKey = _step4.value;
      var publicKeyProperties = Object.keys(publicKey); // the expected fields are id, purpose, type and jwk

      if (publicKeyProperties.length !== 4) {
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerPublicKeyMissingOrUnknownProperty);
      }

      if (typeof publicKey.jwk !== 'object' || Array.isArray(publicKey.jwk)) {
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerPublicKeyJwkMissingOrIncorrectType);
      }

      if (typeof publicKey.type !== 'string') {
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerPublicKeyTypeMissingOrIncorrectType);
      }

      DocumentComposer.validateId(publicKey.id); // 'id' must be unique

      if (publicKeyIdSet.has(publicKey.id)) {
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerPublicKeyIdDuplicated);
      }

      publicKeyIdSet.add(publicKey.id);

      if (!Array.isArray(publicKey.purpose) || publicKey.purpose.length === 0) {
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerPublicKeyPurposeMissingOrUnknown);
      }

      if (publicKey.purpose.length > Object.values(common.PublicKeyPurpose).length) {
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerPublicKeyPurposeExceedsMaxLength);
      }

      var validPurposes = new Set(Object.values(common.PublicKeyPurpose)); // Purpose must be one of the valid ones in KeyPurpose

      for (var _iterator5 = _createForOfIteratorHelperLoose(publicKey.purpose), _step5; !(_step5 = _iterator5()).done;) {
        var purpose = _step5.value;

        if (!validPurposes.has(purpose)) {
          throw new common.SidetreeError(common.ErrorCode.DocumentComposerPublicKeyInvalidPurpose);
        }
      }
    }
  };

  DocumentComposer.validateRemovePublicKeysPatch = function validateRemovePublicKeysPatch(patch) {
    var patchProperties = Object.keys(patch);

    if (patchProperties.length !== 2) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchMissingOrUnknownProperty);
    }

    if (!Array.isArray(patch.public_keys)) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchPublicKeyIdsNotArray);
    }

    for (var _iterator6 = _createForOfIteratorHelperLoose(patch.public_keys), _step6; !(_step6 = _iterator6()).done;) {
      var publicKeyId = _step6.value;

      if (typeof publicKeyId !== 'string') {
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchPublicKeyIdNotString);
      }
    }
  }
  /**
   * validate update patch for removing service endpoints
   */
  ;

  DocumentComposer.validateRemoveServiceEndpointsPatch = function validateRemoveServiceEndpointsPatch(patch) {
    var patchProperties = Object.keys(patch);

    if (patchProperties.length !== 2) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchMissingOrUnknownProperty);
    }

    if (!Array.isArray(patch.ids)) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchServiceEndpointIdsNotArray);
    }

    for (var _iterator7 = _createForOfIteratorHelperLoose(patch.ids), _step7; !(_step7 = _iterator7()).done;) {
      var id = _step7.value;
      DocumentComposer.validateId(id);
    }
  }
  /**
   * Validates update patch for adding service endpoints.
   */
  ;

  DocumentComposer.validateAddServiceEndpointsPatch = function validateAddServiceEndpointsPatch(patch) {
    var patchProperties = Object.keys(patch);

    if (patchProperties.length !== 2) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchMissingOrUnknownProperty);
    }

    if (!Array.isArray(patch.service_endpoints)) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchServiceEndpointsNotArray);
    }

    DocumentComposer.validateServiceEndpoints(patch.service_endpoints);
  }
  /**
   * Validates and parses services endpoints
   * @param service_endpoints the service endpoints to validate and parse
   */
  ;

  DocumentComposer.validateServiceEndpoints = function validateServiceEndpoints(service_endpoints) {
    if (!Array.isArray(service_endpoints)) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchServiceEndpointsNotArray);
    }

    for (var _iterator8 = _createForOfIteratorHelperLoose(service_endpoints), _step8; !(_step8 = _iterator8()).done;) {
      var serviceEndpoint = _step8.value;
      var serviceEndpointProperties = Object.keys(serviceEndpoint);

      if (serviceEndpointProperties.length !== 3) {
        // type, id, and endpoint
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerServiceEndpointMissingOrUnknownProperty);
      }

      DocumentComposer.validateId(serviceEndpoint.id);

      if (typeof serviceEndpoint.type !== 'string') {
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchServiceEndpointTypeNotString);
      }

      if (serviceEndpoint.type.length > 30) {
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchServiceEndpointTypeTooLong);
      }

      if (typeof serviceEndpoint.endpoint !== 'string') {
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchServiceEndpointServiceEndpointNotString);
      }

      if (serviceEndpoint.endpoint.length > 100) {
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchServiceEndpointServiceEndpointTooLong);
      }

      try {
        // just want to validate url, no need to assign to variable, it will throw if not valid
        // tslint:disable-next-line
        new URL(serviceEndpoint.endpoint);
      } catch (_unused) {
        throw new common.SidetreeError(common.ErrorCode.DocumentComposerPatchServiceEndpointServiceEndpointNotValidUrl);
      }
    }
  };

  DocumentComposer.validateId = function validateId(id) {
    if (typeof id !== 'string') {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerIdNotString, "ID not string: " + JSON.stringify(id) + " is of type '" + typeof id + "'");
    }

    if (id.length > 50) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerIdTooLong);
    }

    if (!common.Encoder.isBase64UrlString(id)) {
      throw new common.SidetreeError(common.ErrorCode.DocumentComposerIdNotUsingBase64UrlCharacterSet);
    }
  }
  /**
   * Applies the given patches in order to the given document.
   * NOTE: Assumes no schema validation is needed, since validation should've already occurred at the time of the operation being parsed.
   * @returns The resultant document.
   */
  ;

  DocumentComposer.applyPatches = function applyPatches(document, patches) {
    // Loop through and apply all patches.
    var resultantDocument = document;

    for (var _iterator9 = _createForOfIteratorHelperLoose(patches), _step9; !(_step9 = _iterator9()).done;) {
      var patch = _step9.value;
      resultantDocument = DocumentComposer.applyPatchToDidDocument(resultantDocument, patch);
    }

    return resultantDocument;
  }
  /**
   * Applies the given patch to the given DID Document.
   */
  ;

  DocumentComposer.applyPatchToDidDocument = function applyPatchToDidDocument(document, patch) {
    if (patch.action === 'replace') {
      return patch.document;
    } else if (patch.action === 'add-public-keys') {
      return DocumentComposer.addPublicKeys(document, patch);
    } else if (patch.action === 'remove-public-keys') {
      return DocumentComposer.removePublicKeys(document, patch);
    } else if (patch.action === 'add-service-endpoints') {
      return DocumentComposer.addServiceEndpoints(document, patch);
    } else if (patch.action === 'remove-service-endpoints') {
      return DocumentComposer.removeServiceEndpoints(document, patch);
    } else if (patch.action === 'ietf-json-patch') {
      return DocumentComposer.applyIetfJsonPatch(document, patch);
    }
  };

  DocumentComposer.applyIetfJsonPatch = function applyIetfJsonPatch(document, patch) {
    var res = jsonpatch.applyPatch(_extends({}, document), patch.patches);
    return res.newDocument;
  }
  /**
   * Adds public keys to document.
   */
  ;

  DocumentComposer.addPublicKeys = function addPublicKeys(document, patch) {
    var publicKeyMap = new Map((document.public_keys || []).map(function (publicKey) {
      return [publicKey.id, publicKey];
    })); // Loop through all given public keys and add them if they don't exist already.

    for (var _iterator10 = _createForOfIteratorHelperLoose(patch.public_keys), _step10; !(_step10 = _iterator10()).done;) {
      var publicKey = _step10.value;
      // NOTE: If a key ID already exists, we will just replace the existing key.
      // Not throwing error will minimize the need (thus risk) of reusing exposed update reveal value.
      publicKeyMap.set(publicKey.id, publicKey);
    }

    document.public_keys = Array.from(publicKeyMap.entries()).map(function (pkm) {
      return pkm[1];
    });
    return document;
  }
  /**
   * Removes public keys from document.
   */
  ;

  DocumentComposer.removePublicKeys = function removePublicKeys(document, patch) {
    var publicKeyMap = new Map((document.public_keys || []).map(function (publicKey) {
      return [publicKey.id, publicKey];
    })); // Loop through all given public key IDs and delete them from the existing public key only if it is not a recovery key.

    for (var _iterator11 = _createForOfIteratorHelperLoose(patch.public_keys), _step11; !(_step11 = _iterator11()).done;) {
      var publicKey = _step11.value;
      var existingKey = publicKeyMap.get(publicKey);

      if (existingKey !== undefined) {
        publicKeyMap["delete"](publicKey);
      } // NOTE: Else we will just treat this key removal as a no-op.
      // Not throwing error will minimize the need (thus risk) of reusing exposed update reveal value.

    }

    document.public_keys = Array.from(publicKeyMap.entries()).map(function (pkm) {
      return pkm[1];
    });
    return document;
  };

  DocumentComposer.addServiceEndpoints = function addServiceEndpoints(document, patch) {
    var service_endpoints = patch.service_endpoints;

    if (document.service_endpoints === undefined) {
      // create a new array if service did not exist
      document.service_endpoints = [];
    }

    var idToIndexMapper = new Map(); // map all id and their index

    for (var idx in document.service_endpoints) {
      idToIndexMapper.set(document.service_endpoints[idx].id, idx);
    }

    for (var _iterator12 = _createForOfIteratorHelperLoose(service_endpoints), _step12; !(_step12 = _iterator12()).done;) {
      var serviceEndpoint = _step12.value;

      if (idToIndexMapper.has(serviceEndpoint.id)) {
        var _idx = idToIndexMapper.get(serviceEndpoint.id);

        document.service_endpoints[_idx] = serviceEndpoint;
      } else {
        document.service_endpoints.push(serviceEndpoint);
      }
    }

    return document;
  };

  DocumentComposer.removeServiceEndpoints = function removeServiceEndpoints(document, patch) {
    if (document.service_endpoints === undefined) {
      return document;
    }

    var idsToRemove = new Set(patch.ids);
    document.service_endpoints = document.service_endpoints.filter(function (serviceEndpoint) {
      return !idsToRemove.has(serviceEndpoint.id);
    });
    return document;
  };

  return DocumentComposer;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/main/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var yieldableJson = /*#__PURE__*/require('yieldable-json');
/**
 * A JSON library that performs operations asynchronously.
 */


var JsonAsync = /*#__PURE__*/function () {
  function JsonAsync() {}

  /**
   * Parses the given operation into a JavaScript object asynchronously,
   * to allow the event loop a chance to handle requests.
   */
  JsonAsync.parse =
  /*#__PURE__*/
  function () {
    var _parse = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(jsonData) {
      var jsonParsePromise, result;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // Create a promise to wrap the successful/failed read events.
              jsonParsePromise = new Promise(function (resolve, reject) {
                yieldableJson.parseAsync(jsonData, function (err, data) {
                  if (err) {
                    reject(err);
                  } else {
                    resolve(data);
                  }
                });
              }); // Wait until the JSON parsing is completed.

              _context.next = 3;
              return jsonParsePromise;

            case 3:
              result = _context.sent;
              return _context.abrupt("return", result);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parse(_x) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }();

  return JsonAsync;
}();

/**
 * A class that contains Sidetree operation utility methods.
 */

var OperationUtils = /*#__PURE__*/function () {
  function OperationUtils() {}

  /**
   * Parses the given encoded delta string into an internal `DeltaModel`.
   */
  OperationUtils.parseDelta =
  /*#__PURE__*/
  function () {
    var _parseDelta = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(deltaEncodedString) {
      var deltaJsonString, delta, properties, nextUpdateCommitment;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(typeof deltaEncodedString !== 'string')) {
                _context.next = 2;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.DeltaMissingOrNotString);

            case 2:
              deltaJsonString = common.Encoder.decodeAsString(deltaEncodedString);
              _context.next = 5;
              return JsonAsync.parse(deltaJsonString);

            case 5:
              delta = _context.sent;
              properties = Object.keys(delta);

              if (!(properties.length !== 2)) {
                _context.next = 9;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.DeltaMissingOrUnknownProperty);

            case 9:
              if (!(delta.patches === undefined)) {
                _context.next = 11;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.OperationDocumentPatchesMissing);

            case 11:
              // Validate `patches` property using the DocumentComposer.
              DocumentComposer.validateDocumentPatches(delta.patches);
              nextUpdateCommitment = common.Encoder.decodeAsBuffer(delta.update_commitment);
              common.Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(nextUpdateCommitment);
              return _context.abrupt("return", {
                patches: delta.patches,
                update_commitment: delta.update_commitment
              });

            case 15:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parseDelta(_x) {
      return _parseDelta.apply(this, arguments);
    }

    return parseDelta;
  }();

  return OperationUtils;
}();

/**
 * A class that represents a create operation.
 */

var CreateOperation = /*#__PURE__*/function () {
  /**
   * NOTE: should only be used by `parse()` and `parseObject()` else the contructed instance could be invalid.
   */
  function CreateOperation(operationBuffer, didUniqueSuffix, encodedSuffixData, suffixData, encodedDelta, delta) {
    this.didUniqueSuffix = didUniqueSuffix;
    this.type = common.OperationType.Create;
    this.operationBuffer = operationBuffer;
    this.encodedSuffixData = encodedSuffixData;
    this.suffixData = suffixData;
    this.encodedDelta = encodedDelta;
    this.delta = delta;
  }
  /**
   * Computes the DID unique suffix given the encoded suffix data string.
   */


  CreateOperation.computeDidUniqueSuffix = function computeDidUniqueSuffix(encodedSuffixData) {
    var suffixDataBuffer = common.Encoder.decodeAsBuffer(encodedSuffixData);
    var multihash = common.Multihash.hash(suffixDataBuffer);
    var encodedMultihash = common.Encoder.encode(multihash);
    return encodedMultihash;
  }
  /**
   * Parses the given input as a create operation entry in the anchor file.
   */
  ;

  CreateOperation.parseOperationFromAnchorFile =
  /*#__PURE__*/
  function () {
    var _parseOperationFromAnchorFile = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(input) {
      var operationBuffer, operation;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // Issue #442 - Replace `operationBuffer` in `OperationModel` and `AnchoredOperationModel` with actual operation request
              operationBuffer = Buffer.from(JSON.stringify(input));
              _context.next = 3;
              return CreateOperation.parseObject(input, operationBuffer, true);

            case 3:
              operation = _context.sent;
              return _context.abrupt("return", operation);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parseOperationFromAnchorFile(_x) {
      return _parseOperationFromAnchorFile.apply(this, arguments);
    }

    return parseOperationFromAnchorFile;
  }()
  /**
   * Parses the given buffer as a `CreateOperation`.
   */
  ;

  CreateOperation.parse =
  /*#__PURE__*/
  function () {
    var _parse = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(operationBuffer) {
      var operationJsonString, operationObject, createOperation;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              operationJsonString = operationBuffer.toString();
              _context2.next = 3;
              return JsonAsync.parse(operationJsonString);

            case 3:
              operationObject = _context2.sent;
              _context2.next = 6;
              return CreateOperation.parseObject(operationObject, operationBuffer, false);

            case 6:
              createOperation = _context2.sent;
              return _context2.abrupt("return", createOperation);

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function parse(_x2) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }()
  /**
   * Parses the given operation object as a `CreateOperation`.
   * The `operationBuffer` given is assumed to be valid and is assigned to the `operationBuffer` directly.
   * NOTE: This method is purely intended to be used as an optimization method over the `parse` method in that
   * JSON parsing is not required to be performed more than once when an operation buffer of an unknown operation type is given.
   * @param anchorFileMode If set to true, then `delta` and `type` properties are expected to be absent.
   */
  ;

  CreateOperation.parseObject =
  /*#__PURE__*/
  function () {
    var _parseObject = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(operationObject, operationBuffer, anchorFileMode) {
      var expectedPropertyCount, properties, encodedSuffixData, suffixData, encodedDelta, delta, didUniqueSuffix;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              expectedPropertyCount = 3;

              if (anchorFileMode) {
                expectedPropertyCount = 1;
              }

              properties = Object.keys(operationObject);

              if (!(properties.length !== expectedPropertyCount)) {
                _context3.next = 5;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.CreateOperationMissingOrUnknownProperty);

            case 5:
              encodedSuffixData = operationObject.suffix_data;
              _context3.next = 8;
              return CreateOperation.parseSuffixData(encodedSuffixData);

            case 8:
              suffixData = _context3.sent;
              // If not in anchor file mode, we need to validate `type` and `delta` properties.
              encodedDelta = undefined;
              delta = undefined;

              if (anchorFileMode) {
                _context3.next = 23;
                break;
              }

              if (!(operationObject.type !== common.OperationType.Create)) {
                _context3.next = 14;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.CreateOperationTypeIncorrect);

            case 14:
              encodedDelta = operationObject.delta;
              _context3.prev = 15;
              _context3.next = 18;
              return OperationUtils.parseDelta(operationObject.delta);

            case 18:
              delta = _context3.sent;
              _context3.next = 23;
              break;

            case 21:
              _context3.prev = 21;
              _context3.t0 = _context3["catch"](15);

            case 23:
              didUniqueSuffix = CreateOperation.computeDidUniqueSuffix(operationObject.suffix_data);
              return _context3.abrupt("return", new CreateOperation(operationBuffer, didUniqueSuffix, encodedSuffixData, suffixData, encodedDelta, delta));

            case 25:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[15, 21]]);
    }));

    function parseObject(_x3, _x4, _x5) {
      return _parseObject.apply(this, arguments);
    }

    return parseObject;
  }();

  CreateOperation.parseSuffixData = /*#__PURE__*/function () {
    var _parseSuffixData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(suffixDataEncodedString) {
      var suffixDataJsonString, suffixData, properties, delta_hash, nextRecoveryCommitment;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!(typeof suffixDataEncodedString !== 'string')) {
                _context4.next = 2;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.CreateOperationSuffixDataMissingOrNotString);

            case 2:
              suffixDataJsonString = common.Encoder.decodeAsString(suffixDataEncodedString);
              _context4.next = 5;
              return JsonAsync.parse(suffixDataJsonString);

            case 5:
              suffixData = _context4.sent;
              properties = Object.keys(suffixData);

              if (!(properties.length !== 2)) {
                _context4.next = 9;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.CreateOperationSuffixDataMissingOrUnknownProperty);

            case 9:
              delta_hash = common.Encoder.decodeAsBuffer(suffixData.delta_hash);
              nextRecoveryCommitment = common.Encoder.decodeAsBuffer(suffixData.recovery_commitment);
              common.Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(delta_hash);
              common.Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(nextRecoveryCommitment);
              return _context4.abrupt("return", {
                delta_hash: suffixData.delta_hash,
                recovery_commitment: suffixData.recovery_commitment
              });

            case 14:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function parseSuffixData(_x6) {
      return _parseSuffixData.apply(this, arguments);
    }

    return parseSuffixData;
  }();

  return CreateOperation;
}();

/**
 * Class containing reusable JWK operations.
 */

var Jwk = /*#__PURE__*/function () {
  function Jwk() {}

  /**
   * Generates ED25519 key pair.
   * Mainly used for testing.
   * @returns [publicKey, privateKey]
   */
  Jwk.generateEd25519KeyPair =
  /*#__PURE__*/
  function () {
    var _generateEd25519KeyPair = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var keyPair, privateKey, publicKey;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return jose.JWK.generate('OKP', 'Ed25519');

            case 2:
              keyPair = _context.sent;
              privateKey = keyPair.toJWK(true);
              publicKey = keyPair.toJWK(false);
              return _context.abrupt("return", [publicKey, privateKey]);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function generateEd25519KeyPair() {
      return _generateEd25519KeyPair.apply(this, arguments);
    }

    return generateEd25519KeyPair;
  }() // Helper method to generate keys from a mnemonic
  ;

  Jwk.getBufferAtIndex =
  /*#__PURE__*/
  function () {
    var _getBufferAtIndex = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(mnemonic, index) {
      var seed, root, hdPath, addrNode;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return bip39.mnemonicToSeed(mnemonic);

            case 2:
              seed = _context2.sent;
              root = hdkey.fromMasterSeed(seed); // TODO: 60 is specific to ethereum, we could use another value unique to sidetree

              hdPath = "m/44'/60'/0'/0/" + index;
              addrNode = root.derive(hdPath);
              return _context2.abrupt("return", addrNode.privateKey);

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function getBufferAtIndex(_x, _x2) {
      return _getBufferAtIndex.apply(this, arguments);
    }

    return getBufferAtIndex;
  }();

  Jwk.generateEd25519KeyPairFromMnemonic = /*#__PURE__*/function () {
    var _generateEd25519KeyPairFromMnemonic = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(mnemonic, index) {
      var privateKeyBuffer, keyPair, ed25519KeyPair, publicKeyJwk, privateKeyJwk;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return Jwk.getBufferAtIndex(mnemonic, index);

            case 2:
              privateKeyBuffer = _context3.sent;
              _context3.next = 5;
              return didKeyEd25519.Ed25519KeyPair.generate({
                seed: privateKeyBuffer
              });

            case 5:
              keyPair = _context3.sent;
              ed25519KeyPair = new didKeyEd25519.Ed25519KeyPair(keyPair);
              _context3.next = 9;
              return ed25519KeyPair.toJwk(false);

            case 9:
              publicKeyJwk = _context3.sent;
              _context3.next = 12;
              return ed25519KeyPair.toJwk(true);

            case 12:
              privateKeyJwk = _context3.sent;
              return _context3.abrupt("return", [publicKeyJwk, privateKeyJwk]);

            case 14:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function generateEd25519KeyPairFromMnemonic(_x3, _x4) {
      return _generateEd25519KeyPairFromMnemonic.apply(this, arguments);
    }

    return generateEd25519KeyPairFromMnemonic;
  }()
  /**
   * Generates SECP256K1 key pair.
   * Mainly used for testing.
   * @returns [publicKey, privateKey]
   */
  ;

  Jwk.generateSecp256k1KeyPair =
  /*#__PURE__*/
  function () {
    var _generateSecp256k1KeyPair = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4() {
      var keyPair, publicKey, privateKey;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return jose.JWK.generate('EC', 'secp256k1');

            case 2:
              keyPair = _context4.sent;
              publicKey = keyPair.toJWK(false);
              privateKey = keyPair.toJWK(true);
              return _context4.abrupt("return", [publicKey, privateKey]);

            case 6:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function generateSecp256k1KeyPair() {
      return _generateSecp256k1KeyPair.apply(this, arguments);
    }

    return generateSecp256k1KeyPair;
  }();

  Jwk.generateJwkKeyPairFromMnemonic = /*#__PURE__*/function () {
    var _generateJwkKeyPairFromMnemonic = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(keyType, mnemonic, index) {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.t0 = keyType;
              _context5.next = _context5.t0 === 'secp256k1' ? 3 : _context5.t0 === 'ed25519' ? 4 : 5;
              break;

            case 3:
              return _context5.abrupt("return", this.generateSecp256k1KeyPairFromMnemonic(mnemonic, index));

            case 4:
              return _context5.abrupt("return", this.generateEd25519KeyPairFromMnemonic(mnemonic, index));

            case 5:
              throw new Error('Invalid key type');

            case 6:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function generateJwkKeyPairFromMnemonic(_x5, _x6, _x7) {
      return _generateJwkKeyPairFromMnemonic.apply(this, arguments);
    }

    return generateJwkKeyPairFromMnemonic;
  }();

  Jwk.generateSecp256k1KeyPairFromMnemonic = /*#__PURE__*/function () {
    var _generateSecp256k1KeyPairFromMnemonic = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(mnemonic, index) {
      var privateKeyBuffer, publicKeyJwk, privateKeyJwk;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return Jwk.getBufferAtIndex(mnemonic, index);

            case 2:
              privateKeyBuffer = _context6.sent;
              publicKeyJwk = keyto.from(privateKeyBuffer, 'blk').toJwk('public');
              publicKeyJwk.crv = 'secp256k1';
              privateKeyJwk = keyto.from(privateKeyBuffer, 'blk').toJwk('private');
              privateKeyJwk.crv = 'secp256k1';
              return _context6.abrupt("return", [publicKeyJwk, privateKeyJwk]);

            case 8:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    function generateSecp256k1KeyPairFromMnemonic(_x8, _x9) {
      return _generateSecp256k1KeyPairFromMnemonic.apply(this, arguments);
    }

    return generateSecp256k1KeyPairFromMnemonic;
  }()
  /**
   * Validates the given key is a public key in JWK format allowed by Sidetree.
   * @throws SidetreeError if given object is not a key in JWK format allowed by Sidetree.
   */
  ;

  Jwk.validatePublicJwk = function validatePublicJwk(jwk) {
    if (jwk === undefined) {
      throw new common.SidetreeError(common.ErrorCode.JwkUndefined);
    } // TODO: Check validity with JSON schema...


    var allowedProperties = new Set(['kty', 'crv', 'x', 'y', 'kid']);

    for (var property in jwk) {
      if (!allowedProperties.has(property)) {
        throw new common.SidetreeError(common.ErrorCode.JwkHasUnknownProperty);
      }
    }

    switch (jwk.crv) {
      case 'Ed25519':
        if (jwk.kty !== 'OKP') {
          throw new common.SidetreeError(common.ErrorCode.JwkMissingOrInvalidKty);
        }

        if (typeof jwk.x !== 'string') {
          throw new common.SidetreeError(common.ErrorCode.JwkMissingOrInvalidTypeX);
        }

        break;

      case 'secp256k1':
        if (jwk.kty !== 'EC') {
          throw new common.SidetreeError(common.ErrorCode.JwkMissingOrInvalidKty);
        }

        if (typeof jwk.x !== 'string') {
          throw new common.SidetreeError(common.ErrorCode.JwkMissingOrInvalidTypeX);
        }

        if (typeof jwk.y !== 'string') {
          throw new common.SidetreeError(common.ErrorCode.JwkMissingOrInvalidTypeY);
        }

        break;

      default:
        throw new common.SidetreeError(common.ErrorCode.JwkMissingOrInvalidCrv);
    }
  }
  /**
   * Gets the public key given the private ES256K key.
   * Mainly used for testing purposes.
   */
  ;

  Jwk.getCurve25519PublicKey = function getCurve25519PublicKey(privateKey) {
    var keyCopy = Object.assign({}, privateKey); // Delete the private key portion.

    delete keyCopy.d;
    return keyCopy;
  };

  return Jwk;
}();

/**
 * Class containing reusable JWS operations.
 */

var Jws = /*#__PURE__*/function () {
  /**
   * Constructs a JWS object.
   * @param compactJws Input should be a compact JWS string.
   */
  function Jws(compactJws) {
    if (typeof compactJws !== 'string') {
      throw new common.SidetreeError(common.ErrorCode.JwsCompactJwsNotString);
    }

    var parts = compactJws.split('.');

    if (parts.length !== 3) {
      throw new common.SidetreeError(common.ErrorCode.JwsCompactJwsInvalid);
    }

    var protectedHeader = parts[0];
    var payload = parts[1];
    var signature = parts[2];
    var decodedProtectedHeadJsonString = common.Encoder.decodeBase64UrlAsString(protectedHeader);
    var decodedProtectedHeader = JSON.parse(decodedProtectedHeadJsonString);
    var expectedHeaderPropertyCount = 1; // By default we must have header property is `alg`.

    var headerProperties = Object.keys(decodedProtectedHeader);

    if (headerProperties.length !== expectedHeaderPropertyCount) {
      throw new common.SidetreeError(common.ErrorCode.JwsProtectedHeaderMissingOrUnknownProperty);
    } // Protected header must contain 'alg' property with value 'EdDSA'.


    if (decodedProtectedHeader.alg !== 'EdDSA' && decodedProtectedHeader.alg !== 'ES256K') {
      throw new common.SidetreeError(common.ErrorCode.JwsProtectedHeaderMissingOrIncorrectAlg);
    } // Must contain Base64URL string 'signature' property.


    if (!common.Encoder.isBase64UrlString(signature)) {
      throw new common.SidetreeError(common.ErrorCode.JwsSignatureNotBase64UrlString);
    } // Must contain Base64URL string 'payload' property.


    if (!common.Encoder.isBase64UrlString(payload)) {
      throw new common.SidetreeError(common.ErrorCode.JwsPayloadNotBase64UrlString);
    }

    this["protected"] = protectedHeader;
    this.payload = payload;
    this.signature = signature;
  }
  /**
   * Converts this object to a compact JWS string.
   */


  var _proto = Jws.prototype;

  _proto.toCompactJws = function toCompactJws() {
    return Jws.createCompactJws(this["protected"], this.payload, this.signature);
  }
  /**
   * Verifies the JWS signature.
   * @returns true if signature is successfully verified, false otherwise.
   */
  ;

  _proto.verifySignature =
  /*#__PURE__*/
  function () {
    var _verifySignature = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(publicKey) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", Jws.verifySignature(this["protected"], this.payload, this.signature, publicKey));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function verifySignature(_x) {
      return _verifySignature.apply(this, arguments);
    }

    return verifySignature;
  }()
  /**
   * Verifies the JWS signature.
   * @returns true if signature is successfully verified, false otherwise.
   */
  ;

  Jws.verifySignature =
  /*#__PURE__*/
  function () {
    var _verifySignature2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(encodedProtectedHeader, encodedPayload, signature, publicKey) {
      var jwsSigningInput, signatureValid;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              jwsSigningInput = encodedProtectedHeader + '.' + encodedPayload + '.' + signature;
              _context2.next = 3;
              return Jws.verifyCompactJws(jwsSigningInput, publicKey);

            case 3:
              signatureValid = _context2.sent;
              return _context2.abrupt("return", signatureValid);

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function verifySignature(_x2, _x3, _x4, _x5) {
      return _verifySignature2.apply(this, arguments);
    }

    return verifySignature;
  }()
  /**
   * Verifies the compact JWS string using the given JWK key.
   * @returns true if signature is valid; else otherwise.
   */
  ;

  Jws.verifyCompactJws =
  /*#__PURE__*/
  function () {
    var _verifyCompactJws = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(compactJws, jwk) {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;

              if (!(jwk.crv === 'Ed25519')) {
                _context3.next = 6;
                break;
              }

              _context3.next = 4;
              return didKeyEd25519.EdDSA.verify(compactJws, jwk);

            case 4:
              _context3.next = 12;
              break;

            case 6:
              if (!(jwk.crv === 'secp256k1')) {
                _context3.next = 11;
                break;
              }

              _context3.next = 9;
              return didKeySecp256k1.ES256K.verify(compactJws, jwk);

            case 9:
              _context3.next = 12;
              break;

            case 11:
              return _context3.abrupt("return", false);

            case 12:
              return _context3.abrupt("return", true);

            case 15:
              _context3.prev = 15;
              _context3.t0 = _context3["catch"](0);
              console.log("Input '" + compactJws + "' failed signature verification: " + common.SidetreeError.createFromError(common.ErrorCode.JwsFailedSignatureValidation, _context3.t0));
              return _context3.abrupt("return", false);

            case 19:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[0, 15]]);
    }));

    function verifyCompactJws(_x6, _x7) {
      return _verifyCompactJws.apply(this, arguments);
    }

    return verifyCompactJws;
  }()
  /**
   * Signs the given payload as a compact JWS string.
   * This is mainly used by tests to create valid test data.
   */
  ;

  Jws.signAsCompactJws =
  /*#__PURE__*/
  function () {
    var _signAsCompactJws = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(payload, privateKey, protectedHeader) {
      var alg, header;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (protectedHeader && protectedHeader.alg) {
                alg = protectedHeader.alg;
              } else {
                if (privateKey.crv === 'Ed25519') {
                  alg = 'EdDSA';
                } else {
                  alg = 'ES256K';
                }
              }

              header = _extends({}, protectedHeader, {
                alg: alg
              });

              if (!(privateKey.crv === 'secp256k1')) {
                _context4.next = 6;
                break;
              }

              _context4.next = 5;
              return didKeySecp256k1.ES256K.sign(payload, privateKey, header);

            case 5:
              return _context4.abrupt("return", _context4.sent);

            case 6:
              _context4.next = 8;
              return didKeyEd25519.EdDSA.sign(payload, privateKey, header);

            case 8:
              return _context4.abrupt("return", _context4.sent);

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function signAsCompactJws(_x8, _x9, _x10) {
      return _signAsCompactJws.apply(this, arguments);
    }

    return signAsCompactJws;
  }()
  /**
   * Parses the input as a `Jws` object.
   */
  ;

  Jws.parseCompactJws = function parseCompactJws(compactJws) {
    return new Jws(compactJws);
  }
  /**
   * Creates a compact JWS string using the given input. No string validation is performed.
   */
  ;

  Jws.createCompactJws = function createCompactJws(protectedHeader, payload, signature) {
    return protectedHeader + '.' + payload + '.' + signature;
  };

  return Jws;
}();

/**
 * A class that represents a deactivate operation.
 */

var DeactivateOperation = /*#__PURE__*/function () {
  /**
   * NOTE: should only be used by `parse()` and `parseObject()` else the contructed instance could be invalid.
   */
  function DeactivateOperation(operationBuffer, didUniqueSuffix, signedDataJws, signedData) {
    this.operationBuffer = operationBuffer;
    this.type = common.OperationType.Deactivate;
    this.didUniqueSuffix = didUniqueSuffix;
    this.signedDataJws = signedDataJws;
    this.signedData = signedData;
  }
  /**
   * Parses the given input as a deactivate operation entry in the anchor file.
   */


  DeactivateOperation.parseOperationFromAnchorFile =
  /*#__PURE__*/
  function () {
    var _parseOperationFromAnchorFile = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(input) {
      var operationBuffer, operation;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              operationBuffer = Buffer.from(JSON.stringify(input));
              _context.next = 3;
              return DeactivateOperation.parseObject(input, operationBuffer, true);

            case 3:
              operation = _context.sent;
              return _context.abrupt("return", operation);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parseOperationFromAnchorFile(_x) {
      return _parseOperationFromAnchorFile.apply(this, arguments);
    }

    return parseOperationFromAnchorFile;
  }()
  /**
   * Parses the given buffer as a `UpdateOperation`.
   */
  ;

  DeactivateOperation.parse =
  /*#__PURE__*/
  function () {
    var _parse = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(operationBuffer) {
      var operationJsonString, operationObject, deactivateOperation;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              operationJsonString = operationBuffer.toString();
              _context2.next = 3;
              return JsonAsync.parse(operationJsonString);

            case 3:
              operationObject = _context2.sent;
              _context2.next = 6;
              return DeactivateOperation.parseObject(operationObject, operationBuffer, false);

            case 6:
              deactivateOperation = _context2.sent;
              return _context2.abrupt("return", deactivateOperation);

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function parse(_x2) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }()
  /**
   * Parses the given operation object as a `DeactivateOperation`.
   * The `operationBuffer` given is assumed to be valid and is assigned to the `operationBuffer` directly.
   * NOTE: This method is purely intended to be used as an optimization method over the `parse` method in that
   * JSON parsing is not required to be performed more than once when an operation buffer of an unknown operation type is given.
   * @param anchorFileMode If set to true, then `type` is expected to be absent.
   */
  ;

  DeactivateOperation.parseObject =
  /*#__PURE__*/
  function () {
    var _parseObject = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(operationObject, operationBuffer, anchorFileMode) {
      var expectedPropertyCount, properties, signedDataJws, signedData;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              expectedPropertyCount = 3;

              if (anchorFileMode) {
                expectedPropertyCount = 2;
              }

              properties = Object.keys(operationObject);

              if (!(properties.length !== expectedPropertyCount)) {
                _context3.next = 5;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.DeactivateOperationMissingOrUnknownProperty);

            case 5:
              if (!(typeof operationObject.did_suffix !== 'string')) {
                _context3.next = 7;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.DeactivateOperationMissingOrInvalidDidUniqueSuffix);

            case 7:
              signedDataJws = Jws.parseCompactJws(operationObject.signed_data);
              _context3.next = 10;
              return DeactivateOperation.parseSignedDataPayload(signedDataJws.payload, operationObject.did_suffix);

            case 10:
              signedData = _context3.sent;

              if (anchorFileMode) {
                _context3.next = 14;
                break;
              }

              if (!(operationObject.type !== common.OperationType.Deactivate)) {
                _context3.next = 14;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.DeactivateOperationTypeIncorrect);

            case 14:
              return _context3.abrupt("return", new DeactivateOperation(operationBuffer, operationObject.did_suffix, signedDataJws, signedData));

            case 15:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function parseObject(_x3, _x4, _x5) {
      return _parseObject.apply(this, arguments);
    }

    return parseObject;
  }();

  DeactivateOperation.parseSignedDataPayload = /*#__PURE__*/function () {
    var _parseSignedDataPayload = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(deltaEncodedString, expectedDidUniqueSuffix) {
      var signedDataJsonString, signedData, properties;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              signedDataJsonString = common.Encoder.decodeAsString(deltaEncodedString);
              _context4.next = 3;
              return JsonAsync.parse(signedDataJsonString);

            case 3:
              signedData = _context4.sent;
              properties = Object.keys(signedData);

              if (!(properties.length !== 2)) {
                _context4.next = 7;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.DeactivateOperationSignedDataMissingOrUnknownProperty);

            case 7:
              if (!(signedData.did_suffix !== expectedDidUniqueSuffix)) {
                _context4.next = 9;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.DeactivateOperationSignedDidUniqueSuffixMismatch);

            case 9:
              Jwk.validatePublicJwk(signedData.recovery_key);
              return _context4.abrupt("return", {
                didSuffix: signedData.did_suffix,
                recovery_key: signedData.recovery_key
              });

            case 11:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function parseSignedDataPayload(_x6, _x7) {
      return _parseSignedDataPayload.apply(this, arguments);
    }

    return parseSignedDataPayload;
  }();

  return DeactivateOperation;
}();

/**
 * A class that represents a recover operation.
 */

var RecoverOperation = /*#__PURE__*/function () {
  /**
   * NOTE: should only be used by `parse()` and `parseObject()` else the constructed instance could be invalid.
   */
  function RecoverOperation(operationBuffer, didUniqueSuffix, signedDataJws, signedData, encodedDelta, delta) {
    this.operationBuffer = operationBuffer;
    this.type = common.OperationType.Recover;
    this.didUniqueSuffix = didUniqueSuffix;
    this.signedDataJws = signedDataJws;
    this.signedData = signedData;
    this.encodedDelta = encodedDelta;
    this.delta = delta;
  }
  /**
   * Parses the given input as a recover operation entry in the anchor file.
   */


  RecoverOperation.parseOperationFromAnchorFile =
  /*#__PURE__*/
  function () {
    var _parseOperationFromAnchorFile = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(input) {
      var operationBuffer, operation;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              operationBuffer = Buffer.from(JSON.stringify(input));
              _context.next = 3;
              return RecoverOperation.parseObject(input, operationBuffer, true);

            case 3:
              operation = _context.sent;
              return _context.abrupt("return", operation);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parseOperationFromAnchorFile(_x) {
      return _parseOperationFromAnchorFile.apply(this, arguments);
    }

    return parseOperationFromAnchorFile;
  }()
  /**
   * Parses the given buffer as a `UpdateOperation`.
   */
  ;

  RecoverOperation.parse =
  /*#__PURE__*/
  function () {
    var _parse = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(operationBuffer) {
      var operationJsonString, operationObject, recoverOperation;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              operationJsonString = operationBuffer.toString();
              _context2.next = 3;
              return JsonAsync.parse(operationJsonString);

            case 3:
              operationObject = _context2.sent;
              _context2.next = 6;
              return RecoverOperation.parseObject(operationObject, operationBuffer, false);

            case 6:
              recoverOperation = _context2.sent;
              return _context2.abrupt("return", recoverOperation);

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function parse(_x2) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }()
  /**
   * Parses the given operation object as a `RecoverOperation`.
   * The `operationBuffer` given is assumed to be valid and is assigned to the `operationBuffer` directly.
   * NOTE: This method is purely intended to be used as an optimization method over the `parse` method in that
   * JSON parsing is not required to be performed more than once when an operation buffer of an unknown operation type is given.
   * @param anchorFileMode If set to true, then `delta` and `type` properties are expected to be absent.
   */
  ;

  RecoverOperation.parseObject =
  /*#__PURE__*/
  function () {
    var _parseObject = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(operationObject, operationBuffer, anchorFileMode) {
      var expectedPropertyCount, properties, signedDataJws, signedData, encodedDelta, delta;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              expectedPropertyCount = 4;

              if (anchorFileMode) {
                expectedPropertyCount = 2;
              }

              properties = Object.keys(operationObject);

              if (!(properties.length !== expectedPropertyCount)) {
                _context3.next = 5;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.RecoverOperationMissingOrUnknownProperty);

            case 5:
              if (!(typeof operationObject.did_suffix !== 'string')) {
                _context3.next = 7;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.RecoverOperationMissingOrInvalidDidUniqueSuffix);

            case 7:
              signedDataJws = Jws.parseCompactJws(operationObject.signed_data);
              _context3.next = 10;
              return RecoverOperation.parseSignedDataPayload(signedDataJws.payload);

            case 10:
              signedData = _context3.sent;
              // If not in anchor file mode, we need to validate `type` and `delta` properties.
              encodedDelta = undefined;
              delta = undefined;

              if (anchorFileMode) {
                _context3.next = 25;
                break;
              }

              if (!(operationObject.type !== common.OperationType.Recover)) {
                _context3.next = 16;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.RecoverOperationTypeIncorrect);

            case 16:
              encodedDelta = operationObject.delta;
              _context3.prev = 17;
              _context3.next = 20;
              return OperationUtils.parseDelta(operationObject.delta);

            case 20:
              delta = _context3.sent;
              _context3.next = 25;
              break;

            case 23:
              _context3.prev = 23;
              _context3.t0 = _context3["catch"](17);

            case 25:
              return _context3.abrupt("return", new RecoverOperation(operationBuffer, operationObject.did_suffix, signedDataJws, signedData, encodedDelta, delta));

            case 26:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[17, 23]]);
    }));

    function parseObject(_x3, _x4, _x5) {
      return _parseObject.apply(this, arguments);
    }

    return parseObject;
  }();

  RecoverOperation.parseSignedDataPayload = /*#__PURE__*/function () {
    var _parseSignedDataPayload = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(signedDataEncodedString) {
      var signedDataJsonString, signedData, properties, delta_hash, nextRecoveryCommitmentHash;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              signedDataJsonString = common.Encoder.decodeAsString(signedDataEncodedString);
              _context4.next = 3;
              return JsonAsync.parse(signedDataJsonString);

            case 3:
              signedData = _context4.sent;
              properties = Object.keys(signedData); // TODO: JSON Schema instead of property count type checking...

              if (!(properties.length !== 3)) {
                _context4.next = 7;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.RecoverOperationSignedDataMissingOrUnknownProperty);

            case 7:
              Jwk.validatePublicJwk(signedData.recovery_key);
              delta_hash = common.Encoder.decodeAsBuffer(signedData.delta_hash);
              common.Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(delta_hash);
              nextRecoveryCommitmentHash = common.Encoder.decodeAsBuffer(signedData.recovery_commitment);
              common.Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(nextRecoveryCommitmentHash);
              return _context4.abrupt("return", {
                delta_hash: signedData.delta_hash,
                recovery_key: signedData.recovery_key,
                recovery_commitment: signedData.recovery_commitment
              });

            case 13:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function parseSignedDataPayload(_x6) {
      return _parseSignedDataPayload.apply(this, arguments);
    }

    return parseSignedDataPayload;
  }();

  return RecoverOperation;
}();

/**
 * Class containing Anchor File related operations.
 */

var AnchorFile = /*#__PURE__*/function () {
  /**
   * Class that represents an anchor file.
   * NOTE: this class is introduced as an internal structure in replacement to `AnchorFileModel`
   * to keep useful metadata so that repeated computation can be avoided.
   */
  function AnchorFile(model, didUniqueSuffixes, createOperations, recoverOperations, deactivateOperations) {
    this.model = model;
    this.didUniqueSuffixes = didUniqueSuffixes;
    this.createOperations = createOperations;
    this.recoverOperations = recoverOperations;
    this.deactivateOperations = deactivateOperations;
  }
  /**
   * Parses and validates the given anchor file buffer.
   * @throws `SidetreeError` if failed parsing or validation.
   */


  AnchorFile.parse =
  /*#__PURE__*/
  function () {
    var _parse = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(anchorFileBuffer) {
      var anchorFileDecompressedBuffer, anchorFileModel, allowedProperties, property, mapFileUri, allowedOperationsProperties, operations, _property, didUniqueSuffixes, createOperations, _iterator, _step, operation, createOperation, recoverOperations, _iterator2, _step2, _operation, recoverOperation, deactivateOperations, _iterator3, _step3, _operation2, deactivateOperation, anchorFile;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return Compressor.decompress(anchorFileBuffer);

            case 3:
              anchorFileDecompressedBuffer = _context.sent;
              _context.next = 9;
              break;

            case 6:
              _context.prev = 6;
              _context.t0 = _context["catch"](0);
              throw common.SidetreeError.createFromError(common.ErrorCode.AnchorFileDecompressionFailure, _context.t0);

            case 9:
              _context.prev = 9;
              _context.next = 12;
              return JsonAsync.parse(anchorFileDecompressedBuffer);

            case 12:
              anchorFileModel = _context.sent;
              _context.next = 18;
              break;

            case 15:
              _context.prev = 15;
              _context.t1 = _context["catch"](9);
              throw common.SidetreeError.createFromError(common.ErrorCode.AnchorFileNotJson, _context.t1);

            case 18:
              allowedProperties = new Set(['map_file_uri', 'operations', 'writer_lock_id']);
              _context.t2 = runtime_1.keys(anchorFileModel);

            case 20:
              if ((_context.t3 = _context.t2()).done) {
                _context.next = 26;
                break;
              }

              property = _context.t3.value;

              if (allowedProperties.has(property)) {
                _context.next = 24;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.AnchorFileHasUnknownProperty);

            case 24:
              _context.next = 20;
              break;

            case 26:
              if (Object.prototype.hasOwnProperty.call(anchorFileModel, 'map_file_uri')) {
                _context.next = 28;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.AnchorFileMapFileHashMissing);

            case 28:
              if (Object.prototype.hasOwnProperty.call(anchorFileModel, 'operations')) {
                _context.next = 30;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.AnchorFileMissingOperationsProperty);

            case 30:
              if (!(Object.prototype.hasOwnProperty.call(anchorFileModel, 'writer_lock_id') && typeof anchorFileModel.writer_lock_id !== 'string')) {
                _context.next = 32;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.AnchorFileWriterLockIPropertyNotString);

            case 32:
              // Map file hash validations.
              mapFileUri = anchorFileModel.map_file_uri;

              if (!(typeof mapFileUri !== 'string')) {
                _context.next = 35;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.AnchorFileMapFileHashNotString);

            case 35:
              allowedOperationsProperties = new Set(['create', 'recover', 'deactivate']);
              operations = anchorFileModel.operations;
              _context.t4 = runtime_1.keys(operations);

            case 38:
              if ((_context.t5 = _context.t4()).done) {
                _context.next = 44;
                break;
              }

              _property = _context.t5.value;

              if (allowedOperationsProperties.has(_property)) {
                _context.next = 42;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.AnchorFileUnexpectedPropertyInOperations, "Unexpected property " + _property + " in 'operations' property in anchor file.");

            case 42:
              _context.next = 38;
              break;

            case 44:
              // Will be populated for later validity check.
              didUniqueSuffixes = []; // Validate `create` if exists.

              createOperations = [];

              if (!(operations.create !== undefined)) {
                _context.next = 59;
                break;
              }

              if (Array.isArray(operations.create)) {
                _context.next = 49;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.AnchorFileCreatePropertyNotArray);

            case 49:
              _iterator = _createForOfIteratorHelperLoose(operations.create);

            case 50:
              if ((_step = _iterator()).done) {
                _context.next = 59;
                break;
              }

              operation = _step.value;
              _context.next = 54;
              return CreateOperation.parseOperationFromAnchorFile(operation);

            case 54:
              createOperation = _context.sent;
              createOperations.push(createOperation);
              didUniqueSuffixes.push(createOperation.didUniqueSuffix);

            case 57:
              _context.next = 50;
              break;

            case 59:
              // Validate `recover` if exists.
              recoverOperations = [];

              if (!(operations.recover !== undefined)) {
                _context.next = 73;
                break;
              }

              if (Array.isArray(operations.recover)) {
                _context.next = 63;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.AnchorFileRecoverPropertyNotArray);

            case 63:
              _iterator2 = _createForOfIteratorHelperLoose(operations.recover);

            case 64:
              if ((_step2 = _iterator2()).done) {
                _context.next = 73;
                break;
              }

              _operation = _step2.value;
              _context.next = 68;
              return RecoverOperation.parseOperationFromAnchorFile(_operation);

            case 68:
              recoverOperation = _context.sent;
              recoverOperations.push(recoverOperation);
              didUniqueSuffixes.push(recoverOperation.didUniqueSuffix);

            case 71:
              _context.next = 64;
              break;

            case 73:
              // Validate `deactivate` if exists.
              deactivateOperations = [];

              if (!(operations.deactivate !== undefined)) {
                _context.next = 87;
                break;
              }

              if (Array.isArray(operations.deactivate)) {
                _context.next = 77;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.AnchorFileDeactivatePropertyNotArray);

            case 77:
              _iterator3 = _createForOfIteratorHelperLoose(operations.deactivate);

            case 78:
              if ((_step3 = _iterator3()).done) {
                _context.next = 87;
                break;
              }

              _operation2 = _step3.value;
              _context.next = 82;
              return DeactivateOperation.parseOperationFromAnchorFile(_operation2);

            case 82:
              deactivateOperation = _context.sent;
              deactivateOperations.push(deactivateOperation);
              didUniqueSuffixes.push(deactivateOperation.didUniqueSuffix);

            case 85:
              _context.next = 78;
              break;

            case 87:
              if (!ArrayMethods.hasDuplicates(didUniqueSuffixes)) {
                _context.next = 89;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.AnchorFileMultipleOperationsForTheSameDid);

            case 89:
              anchorFile = new AnchorFile(anchorFileModel, didUniqueSuffixes, createOperations, recoverOperations, deactivateOperations);
              return _context.abrupt("return", anchorFile);

            case 91:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 6], [9, 15]]);
    }));

    function parse(_x) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }()
  /**
   * Creates an `AnchorFileModel`.
   */
  ;

  AnchorFile.createModel =
  /*#__PURE__*/
  function () {
    var _createModel = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(writerLockId, mapFileHash, createOperationArray, recoverOperationArray, deactivateOperationArray) {
      var createOperations, recoverOperations, deactivateOperations, anchorFileModel;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              createOperations = createOperationArray.map(function (operation) {
                return {
                  suffix_data: operation.encodedSuffixData
                };
              });
              recoverOperations = recoverOperationArray.map(function (operation) {
                return {
                  did_suffix: operation.didUniqueSuffix,
                  signed_data: operation.signedDataJws.toCompactJws()
                };
              });
              deactivateOperations = deactivateOperationArray.map(function (operation) {
                return {
                  did_suffix: operation.didUniqueSuffix,
                  signed_data: operation.signedDataJws.toCompactJws()
                };
              });
              anchorFileModel = {
                writer_lock_id: writerLockId,
                map_file_uri: mapFileHash,
                operations: {
                  create: createOperations,
                  recover: recoverOperations,
                  deactivate: deactivateOperations
                }
              };
              return _context2.abrupt("return", anchorFileModel);

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function createModel(_x2, _x3, _x4, _x5, _x6) {
      return _createModel.apply(this, arguments);
    }

    return createModel;
  }()
  /**
   * Creates an anchor file buffer.
   */
  ;

  AnchorFile.createBuffer =
  /*#__PURE__*/
  function () {
    var _createBuffer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(writerLockId, mapFileHash, createOperations, recoverOperations, deactivateOperations) {
      var anchorFileModel, anchorFileJson, anchorFileBuffer;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return AnchorFile.createModel(writerLockId, mapFileHash, createOperations, recoverOperations, deactivateOperations);

            case 2:
              anchorFileModel = _context3.sent;
              anchorFileJson = JSON.stringify(anchorFileModel);
              anchorFileBuffer = Buffer.from(anchorFileJson);
              return _context3.abrupt("return", Compressor.compress(anchorFileBuffer));

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function createBuffer(_x7, _x8, _x9, _x10, _x11) {
      return _createBuffer.apply(this, arguments);
    }

    return createBuffer;
  }();

  return AnchorFile;
}();

/**
 * Class that performs periodic writing of batches of Sidetree operations to CAS and blockchain.
 */

var BatchScheduler = /*#__PURE__*/function () {
  function BatchScheduler(versionManager, blockchain, batchingIntervalInSeconds) {
    this.versionManager = versionManager;
    this.blockchain = blockchain;
    this.batchingIntervalInSeconds = batchingIntervalInSeconds;
    /**
     * Denotes if the periodic batch writing should continue to occur.
     * Used mainly for test purposes.
     */

    this.continuePeriodicBatchWriting = false;
  }
  /**
   * The function that starts periodically anchoring operation batches to blockchain.
   */


  var _proto = BatchScheduler.prototype;

  _proto.startPeriodicBatchWriting = function startPeriodicBatchWriting() {
    var _this = this;

    this.continuePeriodicBatchWriting = true;
    setImmediate( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", _this.writeOperationBatch());

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
  }
  /**
   * Stops periodic batch writing.
   * Mainly used for test purposes.
   */
  ;

  _proto.stopPeriodicBatchWriting = function stopPeriodicBatchWriting() {
    console.info("Stopped periodic batch writing.");
    this.continuePeriodicBatchWriting = false;
  }
  /**
   * Processes the operations in the queue.
   */
  ;

  _proto.writeOperationBatch =
  /*#__PURE__*/
  function () {
    var _writeOperationBatch = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      var _this2 = this;

      var endTimer, currentTime, batchWriter;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              endTimer = timeSpan(); // For calcuating time taken to write operations.

              _context3.prev = 1;
              console.info('Start operation batch writing...'); // Get the correct version of the `BatchWriter`.

              currentTime = this.blockchain.approximateTime.time;
              batchWriter = this.versionManager.getBatchWriter(currentTime);
              _context3.next = 7;
              return batchWriter.write();

            case 7:
              _context3.next = 13;
              break;

            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](1);
              console.error('Unexpected and unhandled error during batch writing, investigate and fix:');
              console.error(_context3.t0);

            case 13:
              _context3.prev = 13;
              console.info("End batch writing. Duration: " + endTimer.rounded() + " ms.");

              if (this.continuePeriodicBatchWriting) {
                console.info("Waiting for " + this.batchingIntervalInSeconds + " seconds before writing another batch.");
                setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
                  return runtime_1.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          return _context2.abrupt("return", _this2.writeOperationBatch());

                        case 1:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })), this.batchingIntervalInSeconds * 1000);
              }

              return _context3.finish(13);

            case 17:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this, [[1, 9, 13, 17]]);
    }));

    function writeOperationBatch() {
      return _writeOperationBatch.apply(this, arguments);
    }

    return writeOperationBatch;
  }();

  return BatchScheduler;
}();

/**
 * Defines schema of a Chunk File and its related operations.
 * NOTE: Must NOT add properties not defined by Sidetree protocol.
 */

var ChunkFile = /*#__PURE__*/function () {
  function ChunkFile() {}

  /**
   * Parses and validates the given chunk file buffer and all the operations within it.
   * @throws SidetreeError if failed parsing or validation.
   */
  ChunkFile.parse =
  /*#__PURE__*/
  function () {
    var _parse = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(chunkFileBuffer) {
      var endTimer, decompressedChunkFileBuffer, chunkFileObject, allowedProperties, property;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              endTimer = timeSpan();
              _context.next = 3;
              return Compressor.decompress(chunkFileBuffer);

            case 3:
              decompressedChunkFileBuffer = _context.sent;
              _context.next = 6;
              return JsonAsync.parse(decompressedChunkFileBuffer);

            case 6:
              chunkFileObject = _context.sent;
              console.info("Parsed chunk file in " + endTimer.rounded() + " ms."); // Ensure only properties specified by Sidetree protocol are given.

              allowedProperties = new Set(['deltas']);
              _context.t0 = runtime_1.keys(chunkFileObject);

            case 10:
              if ((_context.t1 = _context.t0()).done) {
                _context.next = 16;
                break;
              }

              property = _context.t1.value;

              if (allowedProperties.has(property)) {
                _context.next = 14;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.ChunkFileUnexpectedProperty, "Unexpected property " + property + " in chunk file.");

            case 14:
              _context.next = 10;
              break;

            case 16:
              this.validateDeltasProperty(chunkFileObject.deltas);
              return _context.abrupt("return", chunkFileObject);

            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function parse(_x) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }();

  ChunkFile.validateDeltasProperty = function validateDeltasProperty(deltas) {
    // Make sure deltas is an array.
    if (!(deltas instanceof Array)) {
      throw new common.SidetreeError(common.ErrorCode.ChunkFileDeltasPropertyNotArray, 'Invalid chunk file, deltas property is not an array.');
    } // Validate every encoded delta string.


    for (var _iterator = _createForOfIteratorHelperLoose(deltas), _step; !(_step = _iterator()).done;) {
      var encodedDelta = _step.value;

      if (typeof encodedDelta !== 'string') {
        throw new common.SidetreeError(common.ErrorCode.ChunkFileDeltasNotArrayOfStrings, 'Invalid chunk file, deltas property is not an array of strings.');
      }

      var deltaBuffer = Buffer.from(encodedDelta); // Verify size of each delta does not exceed the maximum allowed limit.

      if (deltaBuffer.length > common.protocolParameters.maxDeltaSizeInBytes) {
        throw new common.SidetreeError(common.ErrorCode.ChunkFileDeltaSizeExceedsLimit, "Operation size of " + deltaBuffer.length + " bytes exceeds the allowed limit of " + common.protocolParameters.maxDeltaSizeInBytes + " bytes.");
      }
    }
  }
  /**
   * Creates chunk file buffer.
   */
  ;

  ChunkFile.createBuffer =
  /*#__PURE__*/
  function () {
    var _createBuffer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(createOperations, recoverOperations, updateOperations) {
      var deltas, chunkFileModel, rawData, compressedRawData;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              deltas = [];
              deltas.push.apply(deltas, createOperations.map(function (operation) {
                return operation.encodedDelta;
              }));
              deltas.push.apply(deltas, recoverOperations.map(function (operation) {
                return operation.encodedDelta;
              }));
              deltas.push.apply(deltas, updateOperations.map(function (operation) {
                return operation.encodedDelta;
              }));
              chunkFileModel = {
                deltas: deltas
              };
              rawData = Buffer.from(JSON.stringify(chunkFileModel));
              _context2.next = 8;
              return Compressor.compress(Buffer.from(rawData));

            case 8:
              compressedRawData = _context2.sent;
              return _context2.abrupt("return", compressedRawData);

            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function createBuffer(_x2, _x3, _x4) {
      return _createBuffer.apply(this, arguments);
    }

    return createBuffer;
  }();

  return ChunkFile;
}();

/**
 * A download manager class that performs multiple downloads at the same time.
 */

var DownloadManager = /*#__PURE__*/function () {
  /**
   * Constructs the download manager.
   * @param cas The Content Adressable Store to use for fetching the actual content.
   */
  function DownloadManager(maxConcurrentDownloads, cas) {
    this.maxConcurrentDownloads = maxConcurrentDownloads;
    this.cas = cas;
    this.pendingDownloads = [];
    this.activeDownloads = new Map();
    this.completedDownloads = new Map(); // If maximum concurrent CAS download count is NaN, set it to a default value.

    if (isNaN(maxConcurrentDownloads)) {
      var defaultmaxConcurrentDownloads = 20;
      console.info("Maximum concurrent CAS download count not given, defaulting to " + defaultmaxConcurrentDownloads + ".");
      this.maxConcurrentDownloads = defaultmaxConcurrentDownloads;
    }
  }
  /**
   * Starts pending downloads if maximum concurrent download count is not reached,
   * and resolve downloads that are completed, then invokes this same method again,
   * thus this method must only be invoked once externally as initialization.
   */


  var _proto = DownloadManager.prototype;

  _proto.start = function start() {
    var _this = this;

    try {
      // Move all completed downloads in `activeDownloads` to the `completedDownloads` map.
      var completedDownloadHandles = [];

      for (var _iterator = _createForOfIteratorHelperLoose(this.activeDownloads), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
            _downloadHandle = _step$value[0],
            _downloadInfo = _step$value[1];

        if (_downloadInfo.completed) {
          this.completedDownloads.set(_downloadHandle, _downloadInfo.fetchResult);
          completedDownloadHandles.push(_downloadHandle); // Resolve the promise associated with the download.

          _downloadInfo.resolve();
        }
      }

      for (var _i = 0, _completedDownloadHan = completedDownloadHandles; _i < _completedDownloadHan.length; _i++) {
        var downloadHandle = _completedDownloadHan[_i];
        this.activeDownloads["delete"](downloadHandle);
      } // If maximum concurrent download count is reached, then we can't schedule more downloads.


      var availableDownloadLanes = this.maxConcurrentDownloads - this.activeDownloads.size;

      if (availableDownloadLanes <= 0) {
        return;
      } // Else we can schedule more downloads, but only if there are pending downloads.


      if (this.pendingDownloads.length === 0) {
        return;
      } // Keep start downloading the next queued item until all download lanes are full or there is no more item to download.


      for (var i = 0; i < this.pendingDownloads.length && i < availableDownloadLanes; i++) {
        var downloadInfo = this.pendingDownloads[i]; // Intentionally not awaiting on a download.

        void this.downloadAsync(downloadInfo);
        this.activeDownloads.set(downloadInfo.handle, downloadInfo);
      } // Remove active downloads from `pendingDownloads` list.


      this.pendingDownloads.splice(0, availableDownloadLanes);
    } catch (error) {
      console.error("Encountered unhandled/unexpected error in DownloadManager, must investigate and fix: " + error);
    } finally {
      setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", _this.start());

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })), 1000);
    }
  }
  /**
   * Downloads the content of the given content hash.
   * @param contentHash Hash of the content to be downloaded.
   */
  ;

  _proto.download =
  /*#__PURE__*/
  function () {
    var _download = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(contentHash, maxSizeInBytes) {
      var _this2 = this;

      var handle, fetchPromise, fetchResult;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              handle = crypto.randomBytes(32);
              fetchPromise = new Promise(function (resolve) {
                var downloadInfo = {
                  handle: handle,
                  contentHash: contentHash,
                  maxSizeInBytes: maxSizeInBytes,
                  resolve: resolve,
                  completed: false,
                  content: undefined
                };

                _this2.pendingDownloads.push(downloadInfo);
              });
              _context2.next = 4;
              return fetchPromise;

            case 4:
              fetchResult = this.completedDownloads.get(handle);
              this.completedDownloads["delete"](handle);
              return _context2.abrupt("return", fetchResult);

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function download(_x, _x2) {
      return _download.apply(this, arguments);
    }

    return download;
  }()
  /**
   * The internal download method that gets called by the main download manager monitoring loop when download lanes are available to download content.
   * NOTE: This method MUST NEVER throw (more accurately: ALWAYS set downloadInfo.completed = true),
   * else it will LEAK the available download lanes and in turn hang the Observer.
   * @param downloadInfo Data structure containing `completed` flag and `fetchResult`,
   *                     used to signal to the main download manager monitoring loop when the requested download is completed.
   */
  ;

  _proto.downloadAsync =
  /*#__PURE__*/
  function () {
    var _downloadAsync = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(downloadInfo) {
      var contentHash, fetchResult;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              contentHash = '';
              _context3.prev = 1;
              contentHash = downloadInfo.contentHash;
              _context3.next = 5;
              return this.cas.read(contentHash // downloadInfo.maxSizeInBytes
              );

            case 5:
              fetchResult = _context3.sent;
              downloadInfo.fetchResult = fetchResult;
              _context3.next = 12;
              break;

            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](1);
              console.error("Unexpected error while downloading '" + contentHash + ", investigate and fix " + _context3.t0 + "'.");

            case 12:
              _context3.prev = 12;
              downloadInfo.completed = true;
              return _context3.finish(12);

            case 15:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this, [[1, 9, 12, 15]]);
    }));

    function downloadAsync(_x3) {
      return _downloadAsync.apply(this, arguments);
    }

    return downloadAsync;
  }();

  return DownloadManager;
}();

/**
 * A class that represents an update operation.
 */

var UpdateOperation = /*#__PURE__*/function () {
  /**
   * NOTE: should only be used by `parse()` and `parseObject()` else the contructed instance could be invalid.
   */
  function UpdateOperation(operationBuffer, didUniqueSuffix, signedDataJws, signedData, encodedDelta, delta) {
    this.operationBuffer = operationBuffer;
    this.type = common.OperationType.Update;
    this.didUniqueSuffix = didUniqueSuffix;
    this.signedDataJws = signedDataJws;
    this.signedData = signedData;
    this.encodedDelta = encodedDelta;
    this.delta = delta;
  }
  /**
   * Parses the given input as an update operation entry in the map file.
   */


  UpdateOperation.parseOperationFromMapFile =
  /*#__PURE__*/
  function () {
    var _parseOperationFromMapFile = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(input) {
      var operationBuffer, operation;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              operationBuffer = Buffer.from(JSON.stringify(input));
              _context.next = 3;
              return UpdateOperation.parseObject(input, operationBuffer, true);

            case 3:
              operation = _context.sent;
              return _context.abrupt("return", operation);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parseOperationFromMapFile(_x) {
      return _parseOperationFromMapFile.apply(this, arguments);
    }

    return parseOperationFromMapFile;
  }()
  /**
   * Parses the given buffer as a `UpdateOperation`.
   */
  ;

  UpdateOperation.parse =
  /*#__PURE__*/
  function () {
    var _parse = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(operationBuffer) {
      var operationJsonString, operationObject, updateOperation;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              operationJsonString = operationBuffer.toString();
              _context2.next = 3;
              return JsonAsync.parse(operationJsonString);

            case 3:
              operationObject = _context2.sent;
              _context2.next = 6;
              return UpdateOperation.parseObject(operationObject, operationBuffer, false);

            case 6:
              updateOperation = _context2.sent;
              return _context2.abrupt("return", updateOperation);

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function parse(_x2) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }()
  /**
   * Parses the given operation object as a `UpdateOperation`.
   * The `operationBuffer` given is assumed to be valid and is assigned to the `operationBuffer` directly.
   * NOTE: This method is purely intended to be used as an optimization method over the `parse` method in that
   * JSON parsing is not required to be performed more than once when an operation buffer of an unknown operation type is given.
   * @param mapFileMode If set to true, then `delta` and `type` properties are expected to be absent.
   */
  ;

  UpdateOperation.parseObject =
  /*#__PURE__*/
  function () {
    var _parseObject = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(operationObject, operationBuffer, mapFileMode) {
      var expectedPropertyCount, properties, signedData, signedDataModel, encodedDelta, delta;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              expectedPropertyCount = 4;

              if (mapFileMode) {
                expectedPropertyCount = 2;
              }

              properties = Object.keys(operationObject);

              if (!(properties.length !== expectedPropertyCount)) {
                _context3.next = 5;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.UpdateOperationMissingOrUnknownProperty);

            case 5:
              if (!(typeof operationObject.did_suffix !== 'string')) {
                _context3.next = 7;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.UpdateOperationMissingDidUniqueSuffix);

            case 7:
              signedData = Jws.parseCompactJws(operationObject.signed_data);
              _context3.next = 10;
              return UpdateOperation.parseSignedDataPayload(signedData.payload);

            case 10:
              signedDataModel = _context3.sent;
              // If not in map file mode, we need to validate `type` and `delta` properties.
              encodedDelta = undefined;
              delta = undefined;

              if (mapFileMode) {
                _context3.next = 20;
                break;
              }

              if (!(operationObject.type !== common.OperationType.Update)) {
                _context3.next = 16;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.UpdateOperationTypeIncorrect);

            case 16:
              encodedDelta = operationObject.delta;
              _context3.next = 19;
              return OperationUtils.parseDelta(encodedDelta);

            case 19:
              delta = _context3.sent;

            case 20:
              return _context3.abrupt("return", new UpdateOperation(operationBuffer, operationObject.did_suffix, signedData, signedDataModel, encodedDelta, delta));

            case 21:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function parseObject(_x3, _x4, _x5) {
      return _parseObject.apply(this, arguments);
    }

    return parseObject;
  }();

  UpdateOperation.parseSignedDataPayload = /*#__PURE__*/function () {
    var _parseSignedDataPayload = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(signedDataEncodedString) {
      var signedDataJsonString, signedData, properties, delta_hash;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              signedDataJsonString = common.Encoder.decodeAsString(signedDataEncodedString);
              _context4.next = 3;
              return JsonAsync.parse(signedDataJsonString);

            case 3:
              signedData = _context4.sent;
              properties = Object.keys(signedData);

              if (!(properties.length !== 2)) {
                _context4.next = 7;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.UpdateOperationSignedDataHasMissingOrUnknownProperty);

            case 7:
              Jwk.validatePublicJwk(signedData.update_key);
              delta_hash = common.Encoder.decodeAsBuffer(signedData.delta_hash);
              common.Multihash.verifyHashComputedUsingLatestSupportedAlgorithm(delta_hash);
              return _context4.abrupt("return", {
                delta_hash: signedData.delta_hash,
                update_key: signedData.update_key
              });

            case 11:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function parseSignedDataPayload(_x6) {
      return _parseSignedDataPayload.apply(this, arguments);
    }

    return parseSignedDataPayload;
  }();

  return UpdateOperation;
}();

/**
 * Class containing Map File related operations.
 */

var MapFile = /*#__PURE__*/function () {
  /**
   * Class that represents a map file.
   * NOTE: this class is introduced as an internal structure in replacement to `MapFileModel`
   * to keep useful metadata so that repeated computation can be avoided.
   */
  function MapFile(model, didUniqueSuffixes, updateOperations) {
    this.model = model;
    this.didUniqueSuffixes = didUniqueSuffixes;
    this.updateOperations = updateOperations;
  }
  /**
   * Parses and validates the given map file buffer.
   * @throws `SidetreeError` if failed parsing or validation.
   */


  MapFile.parse =
  /*#__PURE__*/
  function () {
    var _parse = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(mapFileBuffer) {
      var decompressedBuffer, mapFileModel, allowedProperties, property, updateOperations, didUniqueSuffixes, mapFile;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return Compressor.decompress(mapFileBuffer);

            case 3:
              decompressedBuffer = _context.sent;
              _context.next = 9;
              break;

            case 6:
              _context.prev = 6;
              _context.t0 = _context["catch"](0);
              throw common.SidetreeError.createFromError(common.ErrorCode.MapFileDecompressionFailure, _context.t0);

            case 9:
              _context.prev = 9;
              _context.next = 12;
              return JsonAsync.parse(decompressedBuffer);

            case 12:
              mapFileModel = _context.sent;
              _context.next = 18;
              break;

            case 15:
              _context.prev = 15;
              _context.t1 = _context["catch"](9);
              throw common.SidetreeError.createFromError(common.ErrorCode.MapFileNotJson, _context.t1);

            case 18:
              allowedProperties = new Set(['chunks', 'operations']);
              _context.t2 = runtime_1.keys(mapFileModel);

            case 20:
              if ((_context.t3 = _context.t2()).done) {
                _context.next = 26;
                break;
              }

              property = _context.t3.value;

              if (allowedProperties.has(property)) {
                _context.next = 24;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.MapFileHasUnknownProperty);

            case 24:
              _context.next = 20;
              break;

            case 26:
              MapFile.validateChunksProperty(mapFileModel.chunks);
              _context.next = 29;
              return MapFile.parseOperationsProperty(mapFileModel.operations);

            case 29:
              updateOperations = _context.sent;
              didUniqueSuffixes = updateOperations.map(function (operation) {
                return operation.didUniqueSuffix;
              });
              mapFile = new MapFile(mapFileModel, didUniqueSuffixes, updateOperations);
              return _context.abrupt("return", mapFile);

            case 33:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 6], [9, 15]]);
    }));

    function parse(_x) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }()
  /**
   * Validates the given `operations` property, throws error if the property fails validation.
   */
  ;

  MapFile.parseOperationsProperty =
  /*#__PURE__*/
  function () {
    var _parseOperationsProperty = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(operations) {
      var properties, updateOperations, _iterator, _step, operation, updateOperation, didUniqueSuffixes;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(operations === undefined)) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return", []);

            case 2:
              properties = Object.keys(operations);

              if (!(properties.length !== 1)) {
                _context2.next = 5;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.MapFileOperationsPropertyHasMissingOrUnknownProperty);

            case 5:
              updateOperations = [];

              if (Array.isArray(operations.update)) {
                _context2.next = 8;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.MapFileUpdateOperationsNotArray);

            case 8:
              _iterator = _createForOfIteratorHelperLoose(operations.update);

            case 9:
              if ((_step = _iterator()).done) {
                _context2.next = 17;
                break;
              }

              operation = _step.value;
              _context2.next = 13;
              return UpdateOperation.parseOperationFromMapFile(operation);

            case 13:
              updateOperation = _context2.sent;
              updateOperations.push(updateOperation);

            case 15:
              _context2.next = 9;
              break;

            case 17:
              // Make sure no operation with same DID.
              didUniqueSuffixes = updateOperations.map(function (operation) {
                return operation.didUniqueSuffix;
              });

              if (!ArrayMethods.hasDuplicates(didUniqueSuffixes)) {
                _context2.next = 20;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.MapFileMultipleOperationsForTheSameDid);

            case 20:
              return _context2.abrupt("return", updateOperations);

            case 21:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function parseOperationsProperty(_x2) {
      return _parseOperationsProperty.apply(this, arguments);
    }

    return parseOperationsProperty;
  }()
  /**
   * Validates the given `chunks` property, throws error if the property fails validation.
   */
  ;

  MapFile.validateChunksProperty = function validateChunksProperty(chunks) {
    if (!Array.isArray(chunks)) {
      throw new common.SidetreeError(common.ErrorCode.MapFileChunksPropertyMissingOrIncorrectType);
    } // This version expects only one hash.


    if (chunks.length !== 1) {
      throw new common.SidetreeError(common.ErrorCode.MapFileChunksPropertyDoesNotHaveExactlyOneElement);
    }

    var chunk = chunks[0];
    var properties = Object.keys(chunk);

    if (properties.length !== 1) {
      throw new common.SidetreeError(common.ErrorCode.MapFileChunkHasMissingOrUnknownProperty);
    }
  }
  /**
   * Creates the Map File buffer.
   */
  ;

  MapFile.createBuffer =
  /*#__PURE__*/
  function () {
    var _createBuffer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(chunkFileHash, updateOperationArray) {
      var updateOperations, mapFileModel, rawData, compressedRawData;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              updateOperations = updateOperationArray.map(function (operation) {
                return {
                  did_suffix: operation.didUniqueSuffix,
                  signed_data: operation.signedDataJws.toCompactJws()
                };
              });
              mapFileModel = {
                chunks: [{
                  chunk_file_uri: chunkFileHash
                }]
              }; // Only insert an `operations` property if there are update operations.

              if (updateOperations.length > 0) {
                mapFileModel.operations = {
                  update: updateOperations
                };
              }

              rawData = JSON.stringify(mapFileModel);
              _context3.next = 6;
              return Compressor.compress(Buffer.from(rawData));

            case 6:
              compressedRawData = _context3.sent;
              return _context3.abrupt("return", compressedRawData);

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function createBuffer(_x3, _x4) {
      return _createBuffer.apply(this, arguments);
    }

    return createBuffer;
  }();

  return MapFile;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/main/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Keeps track of current block and throughput limits based on the state
 */
var ThroughputLimiter = /*#__PURE__*/function () {
  function ThroughputLimiter(versionManager) {
    this.versionManager = versionManager;
  }
  /**
   * given a an array of transactions, return an array of qualified transactions per transaction time.
   * @param transactions array of transactions to filter for
   */


  var _proto = ThroughputLimiter.prototype;

  _proto.getQualifiedTransactions =
  /*#__PURE__*/
  function () {
    var _getQualifiedTransactions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(transactions) {
      var currentTransactionTime, transactionsGroupedByTransactionTime, _iterator, _step, transaction, qualifiedTransactions, _i, _transactionsGroupedB, transactionGroup, transactionSelector, qualifiedTransactionsInCurrentGroup;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              currentTransactionTime = undefined;
              transactionsGroupedByTransactionTime = [];

              for (_iterator = _createForOfIteratorHelperLoose(transactions); !(_step = _iterator()).done;) {
                transaction = _step.value;

                // If transaction is transitioning into a new time, create a new grouping.
                if (transaction.transactionTime !== currentTransactionTime) {
                  transactionsGroupedByTransactionTime.push([]);
                  currentTransactionTime = transaction.transactionTime;
                }

                transactionsGroupedByTransactionTime[transactionsGroupedByTransactionTime.length - 1].push(transaction);
              }

              qualifiedTransactions = [];
              _i = 0, _transactionsGroupedB = transactionsGroupedByTransactionTime;

            case 5:
              if (!(_i < _transactionsGroupedB.length)) {
                _context.next = 15;
                break;
              }

              transactionGroup = _transactionsGroupedB[_i];
              transactionSelector = this.versionManager.getTransactionSelector(transactionGroup[0].transactionTime);
              _context.next = 10;
              return transactionSelector.selectQualifiedTransactions(transactionGroup);

            case 10:
              qualifiedTransactionsInCurrentGroup = _context.sent;
              qualifiedTransactions.push.apply(qualifiedTransactions, qualifiedTransactionsInCurrentGroup);

            case 12:
              _i++;
              _context.next = 5;
              break;

            case 15:
              return _context.abrupt("return", qualifiedTransactions);

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getQualifiedTransactions(_x) {
      return _getQualifiedTransactions.apply(this, arguments);
    }

    return getQualifiedTransactions;
  }();

  return ThroughputLimiter;
}();

/**
 * Class that performs periodic processing of batches of Sidetree operations anchored to the blockchain.
 */

var Observer = /*#__PURE__*/function () {
  function Observer(versionManager, blockchain, maxConcurrentDownloads, operationStore, transactionStore, unresolvableTransactionStore, observingIntervalInSeconds) {
    this.versionManager = versionManager;
    this.blockchain = blockchain;
    this.maxConcurrentDownloads = maxConcurrentDownloads;
    this.operationStore = operationStore;
    this.transactionStore = transactionStore;
    this.unresolvableTransactionStore = unresolvableTransactionStore;
    this.observingIntervalInSeconds = observingIntervalInSeconds;
    /**
     * Denotes if the periodic transaction processing should continue to occur.
     * Used mainly for test purposes.
     */

    this.continuePeriodicProcessing = false;
    /**
     * The list of transactions that are being downloaded or processed.
     */

    this.transactionsUnderProcessing = [];
    this.throughputLimiter = new ThroughputLimiter(versionManager);
  }

  var _proto = Observer.prototype;

  _proto.refreshLastKnownTransaction = /*#__PURE__*/function () {
    var _refreshLastKnownTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.transactionStore.getLastTransaction();

            case 2:
              this.lastKnownTransaction = _context.sent;

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function refreshLastKnownTransaction() {
      return _refreshLastKnownTransaction.apply(this, arguments);
    }

    return refreshLastKnownTransaction;
  }()
  /**
   * The method that starts the periodic polling and processing of Sidetree operations.
   */
  ;

  _proto.startPeriodicProcessing =
  /*#__PURE__*/
  function () {
    var _startPeriodicProcessing = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      var _this = this;

      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.refreshLastKnownTransaction();

            case 2:
              console.info("Starting periodic transactions processing.");
              setImmediate( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
                return runtime_1.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _this.continuePeriodicProcessing = true; // tslint:disable-next-line:no-floating-promises - this.processTransactions() never throws.

                        _this.processTransactions();

                      case 2:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              })));

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function startPeriodicProcessing() {
      return _startPeriodicProcessing.apply(this, arguments);
    }

    return startPeriodicProcessing;
  }()
  /**
   * Stops periodic transaction processing.
   * Mainly used for test purposes.
   */
  ;

  _proto.stopPeriodicProcessing = function stopPeriodicProcessing() {
    console.info("Stopped periodic transactions processing.");
    this.continuePeriodicProcessing = false;
  }
  /**
   * Processes new transactions if any, then reprocess a set of unresolvable transactions if any,
   * then schedules the next round of processing unless `stopPeriodicProcessing()` is invoked.
   */
  ;

  _proto.processTransactions =
  /*#__PURE__*/
  function () {
    var _processTransactions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(awaitTransactionProcessing) {
      var _this2 = this;

      var moreTransactions, lastKnownTransactionNumber, lastKnownTransactionTimeHash, lastKnownTransactionTime, invalidTransactionNumberOrTimeHash, readResult, endTimer, nextTransactionNumber, transactions, qualifiedTransactions, _iterator, _step, transaction, awaitingTransaction, blockReorganizationDetected;

      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (awaitTransactionProcessing === void 0) {
                awaitTransactionProcessing = false;
              }

              _context5.prev = 1;
              _context5.next = 4;
              return this.storeConsecutiveTransactionsProcessed();

            case 4:
              // Do this in multiple places
              // Keep fetching new Sidetree transactions from blockchain and processing them
              // until there are no more new transactions or there is a block reorganization.
              moreTransactions = false;

            case 5:
              // Get the last transaction to be used as a timestamp to fetch new transactions.
              lastKnownTransactionNumber = this.lastKnownTransaction ? this.lastKnownTransaction.transactionNumber : undefined;
              lastKnownTransactionTimeHash = this.lastKnownTransaction ? this.lastKnownTransaction.transactionTimeHash : undefined;
              lastKnownTransactionTime = this.lastKnownTransaction ? this.lastKnownTransaction.transactionTime : 0;
              invalidTransactionNumberOrTimeHash = false;
              readResult = void 0;
              endTimer = timeSpan(); // Measure time taken to go blockchain read.

              _context5.prev = 11;
              console.info('Fetching Sidetree transactions from blockchain service...');
              nextTransactionNumber = lastKnownTransactionNumber !== undefined ? lastKnownTransactionNumber + 1 : undefined;
              _context5.next = 16;
              return this.blockchain.read(nextTransactionNumber, lastKnownTransactionTimeHash);

            case 16:
              readResult = _context5.sent;
              console.info("Fetched " + readResult.transactions.length + " Sidetree transactions from blockchain service in " + endTimer.rounded() + " ms.");
              _context5.next = 28;
              break;

            case 20:
              _context5.prev = 20;
              _context5.t0 = _context5["catch"](11);

              if (!(_context5.t0 instanceof common.SidetreeError && _context5.t0.code === common.SharedErrorCode.InvalidTransactionNumberOrTimeHash)) {
                _context5.next = 27;
                break;
              }

              console.info("Invalid transaction number " + lastKnownTransactionNumber + " or time hash " + lastKnownTransactionTimeHash + " given to blockchain service.");
              invalidTransactionNumberOrTimeHash = true;
              _context5.next = 28;
              break;

            case 27:
              throw _context5.t0;

            case 28:
              transactions = readResult ? readResult.transactions : [];
              moreTransactions = readResult ? readResult.moreTransactions : false;
              _context5.next = 32;
              return this.throughputLimiter.getQualifiedTransactions(transactions);

            case 32:
              qualifiedTransactions = _context5.sent;
              qualifiedTransactions = qualifiedTransactions.sort(function (a, b) {
                return a.transactionNumber - b.transactionNumber;
              }); // Queue parallel downloading and processing of chunk files.

              _iterator = _createForOfIteratorHelperLoose(qualifiedTransactions);

            case 35:
              if ((_step = _iterator()).done) {
                _context5.next = 47;
                break;
              }

              transaction = _step.value;
              awaitingTransaction = {
                transaction: transaction,
                processingStatus: common.TransactionProcessingStatus.Pending
              };
              this.transactionsUnderProcessing.push(awaitingTransaction);

              if (!awaitTransactionProcessing) {
                _context5.next = 44;
                break;
              }

              _context5.next = 42;
              return this.processTransaction(transaction, awaitingTransaction);

            case 42:
              _context5.next = 45;
              break;

            case 44:
              // Intentionally not awaiting on downloading and processing each operation batch.
              void this.processTransaction(transaction, awaitingTransaction);

            case 45:
              _context5.next = 35;
              break;

            case 47:
              // NOTE: Blockchain reorg has happened for sure only if `invalidTransactionNumberOrTimeHash` AND
              // latest transaction time is less or equal to blockchain service time.
              // This check will prevent Core from reverting transactions if/when blockchain service is reinitializing its data itself.
              blockReorganizationDetected = false;

              if (invalidTransactionNumberOrTimeHash) {
                if (lastKnownTransactionTime <= this.blockchain.approximateTime.time) {
                  blockReorganizationDetected = true;
                  moreTransactions = true;
                } else {
                  console.info("Blockchain microservice blockchain time is behind last known transaction time, waiting for blockchain microservice to catch up...");
                }
              } // If block reorg is detected, we must wait until no more operation processing is pending,
              // then revert invalid transaction and operations.


              if (!blockReorganizationDetected) {
                _context5.next = 59;
                break;
              }

              console.info("Block reorganization detected.");
              _context5.next = 53;
              return this.waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo(0);

            case 53:
              console.info("Reverting invalid transactions...");
              _context5.next = 56;
              return this.revertInvalidTransactions();

            case 56:
              console.info("Completed reverting invalid transactions.");
              _context5.next = 61;
              break;

            case 59:
              _context5.next = 61;
              return this.waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo(this.maxConcurrentDownloads);

            case 61:
              // Update the last known transaction.
              // NOTE: In case of block reorg, last known transaction will be updated in `this.RevertInvalidTransactions()` method.
              if (transactions && transactions.length > 0) {
                this.lastKnownTransaction = transactions[transactions.length - 1];
              }

            case 62:
              if (moreTransactions) {
                _context5.next = 5;
                break;
              }

            case 63:
              _context5.next = 65;
              return this.storeConsecutiveTransactionsProcessed();

            case 65:
              console.info('Successfully kicked off downloading/processing of all new Sidetree transactions.'); // Continue onto processing unresolvable transactions if any.

              _context5.next = 68;
              return this.processUnresolvableTransactions(awaitTransactionProcessing);

            case 68:
              _context5.next = 74;
              break;

            case 70:
              _context5.prev = 70;
              _context5.t1 = _context5["catch"](1);
              console.error("Encountered unhandled and possibly fatal Observer error, must investigate and fix:");
              console.error(_context5.t1);

            case 74:
              _context5.prev = 74;

              if (this.continuePeriodicProcessing) {
                console.info("Waiting for " + this.observingIntervalInSeconds + " seconds before fetching and processing transactions again.");
                setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4() {
                  return runtime_1.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          return _context4.abrupt("return", _this2.processTransactions());

                        case 1:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                })), this.observingIntervalInSeconds * 1000);
              }

              return _context5.finish(74);

            case 77:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this, [[1, 70, 74, 77], [11, 20]]);
    }));

    function processTransactions(_x) {
      return _processTransactions.apply(this, arguments);
    }

    return processTransactions;
  }();

  _proto.waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo = /*#__PURE__*/function () {
    var _waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(count) {
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (!(this.transactionsUnderProcessing.length > count)) {
                _context6.next = 7;
                break;
              }

              _context6.next = 3;
              return this.storeConsecutiveTransactionsProcessed();

            case 3:
              _context6.next = 5;
              return new Promise(function (resolve) {
                return setTimeout(resolve, 1000);
              });

            case 5:
              _context6.next = 0;
              break;

            case 7:
              return _context6.abrupt("return");

            case 8:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo(_x2) {
      return _waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo.apply(this, arguments);
    }

    return waitUntilCountOfTransactionsUnderProcessingIsLessOrEqualTo;
  }()
  /**
   * Attempts to fetch and process unresolvable transactions due for retry.
   * Waits until all unresolvable transactions due for retry are processed.
   */
  ;

  _proto.processUnresolvableTransactions =
  /*#__PURE__*/
  function () {
    var _processUnresolvableTransactions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(awaitTransactionProcessing) {
      var endTimer, unresolvableTransactions, unresolvableTransactionStatus, _iterator2, _step2, transaction, awaitingTransaction, i;

      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (awaitTransactionProcessing === void 0) {
                awaitTransactionProcessing = false;
              }

              endTimer = timeSpan();
              _context7.next = 4;
              return this.unresolvableTransactionStore.getUnresolvableTransactionsDueForRetry();

            case 4:
              unresolvableTransactions = _context7.sent;
              console.info("Fetched " + unresolvableTransactions.length + " unresolvable transactions to retry in " + endTimer.rounded() + " ms."); // Download and process each unresolvable transactions.

              unresolvableTransactionStatus = [];
              _iterator2 = _createForOfIteratorHelperLoose(unresolvableTransactions);

            case 8:
              if ((_step2 = _iterator2()).done) {
                _context7.next = 20;
                break;
              }

              transaction = _step2.value;
              awaitingTransaction = {
                transaction: transaction,
                processingStatus: common.TransactionProcessingStatus.Pending
              };
              unresolvableTransactionStatus.push(awaitingTransaction); // Intentionally not awaiting on downloading and processing each operation batch.

              if (!awaitTransactionProcessing) {
                _context7.next = 17;
                break;
              }

              _context7.next = 15;
              return this.processTransaction(transaction, awaitingTransaction);

            case 15:
              _context7.next = 18;
              break;

            case 17:
              // Intentionally not awaiting on downloading and processing each operation batch.
              void this.processTransaction(transaction, awaitingTransaction);

            case 18:
              _context7.next = 8;
              break;

            case 20:
              if (!(unresolvableTransactionStatus.length > 0)) {
                _context7.next = 28;
                break;
              }

              // Find the index of the first transaction that is not processed yet.
              i = 0;

              while (i < unresolvableTransactionStatus.length && unresolvableTransactionStatus[i].processingStatus === common.TransactionProcessingStatus.Processed) {
                i++;
              } // Trim the parallelized transaction list.


              unresolvableTransactionStatus.splice(0, i); // Wait a little before checking again.

              _context7.next = 26;
              return new Promise(function (resolve) {
                return setTimeout(resolve, 1000);
              });

            case 26:
              _context7.next = 20;
              break;

            case 28:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function processUnresolvableTransactions(_x3) {
      return _processUnresolvableTransactions.apply(this, arguments);
    }

    return processUnresolvableTransactions;
  }()
  /**
   * Goes through the `transactionsUnderProcessing` in chronological order, records each processed transaction
   * in the transaction store and remove it from `transactionsUnderProcessing` until a transaction that has not been processed yet is hit.
   */
  ;

  _proto.storeConsecutiveTransactionsProcessed =
  /*#__PURE__*/
  function () {
    var _storeConsecutiveTransactionsProcessed = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8() {
      var i;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              i = 0;

            case 1:
              if (!(i < this.transactionsUnderProcessing.length && this.transactionsUnderProcessing[i].processingStatus === common.TransactionProcessingStatus.Processed)) {
                _context8.next = 7;
                break;
              }

              _context8.next = 4;
              return this.transactionStore.addTransaction(this.transactionsUnderProcessing[i].transaction);

            case 4:
              i++;
              _context8.next = 1;
              break;

            case 7:
              // Trim the transaction list.
              this.transactionsUnderProcessing.splice(0, i);

            case 8:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function storeConsecutiveTransactionsProcessed() {
      return _storeConsecutiveTransactionsProcessed.apply(this, arguments);
    }

    return storeConsecutiveTransactionsProcessed;
  }()
  /**
   * Processes the given transaction by passing the transaction to the right version of the transaction processor based on the transaction time.
   * The transaction processing generically involves first downloading DID operation data from CAS (Content Addressable Storage),
   * then storing the operations indexed/grouped by DIDs in the persistent operation DB.
   */
  ;

  _proto.processTransaction =
  /*#__PURE__*/
  function () {
    var _processTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(transaction, transactionUnderProcessing) {
      var transactionProcessedSuccessfully, transactionProcessor;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.prev = 0;
              transactionProcessor = this.versionManager.getTransactionProcessor(transaction.transactionTime);
              _context9.next = 4;
              return transactionProcessor.processTransaction(transaction);

            case 4:
              transactionProcessedSuccessfully = _context9.sent;
              _context9.next = 12;
              break;

            case 7:
              _context9.prev = 7;
              _context9.t0 = _context9["catch"](0);
              console.error("Unhandled error encountered processing transaction '" + transaction.transactionNumber + "'.");
              console.error(_context9.t0);
              transactionProcessedSuccessfully = false;

            case 12:
              _context9.prev = 12;
              // Purposely setting processing status first before rest of the code to prevent any possibility of deadlocking the Observer.
              console.info("Finished processing transaction '" + transaction.transactionNumber + "'.");
              transactionUnderProcessing.processingStatus = common.TransactionProcessingStatus.Processed;

              if (!transactionProcessedSuccessfully) {
                _context9.next = 21;
                break;
              }

              console.info("Removing transaction '" + transaction.transactionNumber + "' from unresolvable transactions if exists...");
              _context9.next = 19;
              return this.unresolvableTransactionStore.removeUnresolvableTransaction(transaction);

            case 19:
              _context9.next = 24;
              break;

            case 21:
              console.info("Recording failed processing attempt for transaction '" + transaction.transactionNumber + "'...");
              _context9.next = 24;
              return this.unresolvableTransactionStore.recordUnresolvableTransactionFetchAttempt(transaction);

            case 24:
              return _context9.finish(12);

            case 25:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this, [[0, 7, 12, 25]]);
    }));

    function processTransaction(_x4, _x5) {
      return _processTransaction.apply(this, arguments);
    }

    return processTransaction;
  }()
  /**
   * Reverts invalid transactions. Used in the event of a block-reorganization.
   */
  ;

  _proto.revertInvalidTransactions =
  /*#__PURE__*/
  function () {
    var _revertInvalidTransactions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10() {
      var exponentiallySpacedTransactions, bestKnownValidRecentTransaction, bestKnownValidRecentTransactionNumber;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return this.transactionStore.getExponentiallySpacedTransactions();

            case 2:
              exponentiallySpacedTransactions = _context10.sent;
              _context10.next = 5;
              return this.blockchain.getFirstValidTransaction(exponentiallySpacedTransactions);

            case 5:
              bestKnownValidRecentTransaction = _context10.sent;
              bestKnownValidRecentTransactionNumber = bestKnownValidRecentTransaction === undefined ? undefined : bestKnownValidRecentTransaction.transactionNumber;
              console.info("Best known valid recent transaction: " + bestKnownValidRecentTransactionNumber); // Revert all processed operations that came after the best known valid recent transaction.

              console.info('Reverting operations...');
              _context10.next = 11;
              return this.operationStore["delete"](bestKnownValidRecentTransactionNumber);

            case 11:
              _context10.next = 13;
              return this.transactionStore.removeTransactionsLaterThan(bestKnownValidRecentTransactionNumber);

            case 13:
              _context10.next = 15;
              return this.unresolvableTransactionStore.removeUnresolvableTransactionsLaterThan(bestKnownValidRecentTransactionNumber);

            case 15:
              // Reset the in-memory last known good Transaction so we next processing cycle will fetch from the correct timestamp/maker.
              this.lastKnownTransaction = bestKnownValidRecentTransaction;

            case 16:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function revertInvalidTransactions() {
      return _revertInvalidTransactions.apply(this, arguments);
    }

    return revertInvalidTransactions;
  }();

  return Observer;
}();

/**
 * A class that contains Sidetree operation utility methods.
 */

var Operation = /*#__PURE__*/function () {
  function Operation() {}

  /**
   * Parses the given buffer into an `OperationModel`.
   */
  Operation.parse =
  /*#__PURE__*/
  function () {
    var _parse = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(operationBuffer) {
      var operationJsonString, operationObject, operationType, isAnchorFileMode;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // Parse request buffer into a JS object.
              operationJsonString = operationBuffer.toString();
              operationObject = JSON.parse(operationJsonString);
              operationType = operationObject.type;
              isAnchorFileMode = false;

              if (!(operationType === common.OperationType.Create)) {
                _context.next = 8;
                break;
              }

              return _context.abrupt("return", CreateOperation.parseObject(operationObject, operationBuffer, isAnchorFileMode));

            case 8:
              if (!(operationType === common.OperationType.Update)) {
                _context.next = 12;
                break;
              }

              return _context.abrupt("return", UpdateOperation.parseObject(operationObject, operationBuffer, isAnchorFileMode));

            case 12:
              if (!(operationType === common.OperationType.Recover)) {
                _context.next = 16;
                break;
              }

              return _context.abrupt("return", RecoverOperation.parseObject(operationObject, operationBuffer, isAnchorFileMode));

            case 16:
              if (!(operationType === common.OperationType.Deactivate)) {
                _context.next = 20;
                break;
              }

              return _context.abrupt("return", DeactivateOperation.parseObject(operationObject, operationBuffer, isAnchorFileMode));

            case 20:
              throw new common.SidetreeError(common.ErrorCode.OperationTypeUnknownOrMissing);

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parse(_x) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }();

  return Operation;
}();
Operation.maxEncodedRevealValueLength = 50;

/**
 * A class that can generate valid operations.
 * Mainly useful for testing purposes.
 */

var OperationGenerator = /*#__PURE__*/function () {
  function OperationGenerator() {}

  /**
   * Generates random hash.
   */
  OperationGenerator.generateRandomHash = function generateRandomHash() {
    var randomBuffer = crypto.randomBytes(32);
    var randomHash = common.Encoder.encode(common.Multihash.hash(randomBuffer));
    return randomHash;
  }
  /**
   * Generates Ed25519 key pair to be used in an operation. If purpose not supplied, all purposes will be included
   * Mainly used for testing.
   * @returns [publicKey, privateKey]
   */
  ;

  OperationGenerator.generateKeyPair =
  /*#__PURE__*/
  function () {
    var _generateKeyPair = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(id, purpose) {
      var _yield$Jwk$generateEd, publicKey, privateKey, publicKeyModel;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return Jwk.generateEd25519KeyPair();

            case 2:
              _yield$Jwk$generateEd = _context.sent;
              publicKey = _yield$Jwk$generateEd[0];
              privateKey = _yield$Jwk$generateEd[1];
              publicKeyModel = {
                id: id,
                type: 'Ed25519VerificationKey2018',
                jwk: publicKey,
                purpose: purpose || Object.values(common.PublicKeyPurpose)
              };
              return _context.abrupt("return", [publicKeyModel, privateKey]);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function generateKeyPair(_x, _x2) {
      return _generateKeyPair.apply(this, arguments);
    }

    return generateKeyPair;
  }()
  /**
   * Generates an anchored create operation.
   */
  ;

  OperationGenerator.generateAnchoredCreateOperation =
  /*#__PURE__*/
  function () {
    var _generateAnchoredCreateOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(input) {
      var createOperationData, anchoredOperationModel;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return OperationGenerator.generateCreateOperation();

            case 2:
              createOperationData = _context2.sent;
              anchoredOperationModel = {
                type: common.OperationType.Create,
                didUniqueSuffix: createOperationData.createOperation.didUniqueSuffix,
                operationBuffer: createOperationData.createOperation.operationBuffer,
                transactionNumber: input.transactionNumber,
                transactionTime: input.transactionTime,
                operationIndex: input.operationIndex
              };
              return _context2.abrupt("return", {
                createOperation: createOperationData.createOperation,
                operationRequest: createOperationData.operationRequest,
                anchoredOperationModel: anchoredOperationModel,
                recoveryPublicKey: createOperationData.recoveryPublicKey,
                recoveryPrivateKey: createOperationData.recoveryPrivateKey,
                updatePublicKey: createOperationData.updatePublicKey,
                updatePrivateKey: createOperationData.updatePrivateKey,
                signingPublicKey: createOperationData.signingPublicKey,
                signingPrivateKey: createOperationData.signingPrivateKey,
                nextUpdateRevealValueEncodedString: createOperationData.nextUpdateRevealValueEncodedString
              });

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function generateAnchoredCreateOperation(_x3) {
      return _generateAnchoredCreateOperation.apply(this, arguments);
    }

    return generateAnchoredCreateOperation;
  }()
  /**
   * Generates an create operation.
   */
  ;

  OperationGenerator.generateCreateOperation =
  /*#__PURE__*/
  function () {
    var _generateCreateOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      var signingKeyId, _yield$Jwk$generateEd2, recoveryPublicKey, recoveryPrivateKey, _yield$Jwk$generateEd3, updatePublicKey, updatePrivateKey, _yield$OperationGener, signingPublicKey, signingPrivateKey, service, operationRequest, operationBuffer, createOperation, nextUpdateRevealValueEncodedString;

      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              signingKeyId = 'signingKey';
              _context3.next = 3;
              return Jwk.generateEd25519KeyPair();

            case 3:
              _yield$Jwk$generateEd2 = _context3.sent;
              recoveryPublicKey = _yield$Jwk$generateEd2[0];
              recoveryPrivateKey = _yield$Jwk$generateEd2[1];
              _context3.next = 8;
              return Jwk.generateEd25519KeyPair();

            case 8:
              _yield$Jwk$generateEd3 = _context3.sent;
              updatePublicKey = _yield$Jwk$generateEd3[0];
              updatePrivateKey = _yield$Jwk$generateEd3[1];
              _context3.next = 13;
              return OperationGenerator.generateKeyPair(signingKeyId);

            case 13:
              _yield$OperationGener = _context3.sent;
              signingPublicKey = _yield$OperationGener[0];
              signingPrivateKey = _yield$OperationGener[1];
              service = OperationGenerator.generateServiceEndpoints(['serviceEndpointId123']);
              _context3.next = 19;
              return OperationGenerator.generateCreateOperationRequest(recoveryPublicKey, updatePublicKey, [signingPublicKey], service);

            case 19:
              operationRequest = _context3.sent;
              operationBuffer = Buffer.from(JSON.stringify(operationRequest));
              _context3.next = 23;
              return CreateOperation.parse(operationBuffer);

            case 23:
              createOperation = _context3.sent;
              nextUpdateRevealValueEncodedString = common.Multihash.canonicalizeThenHashThenEncode(signingPublicKey.jwk);
              return _context3.abrupt("return", {
                createOperation: createOperation,
                operationRequest: operationRequest,
                recoveryPublicKey: recoveryPublicKey,
                recoveryPrivateKey: recoveryPrivateKey,
                updatePublicKey: updatePublicKey,
                updatePrivateKey: updatePrivateKey,
                signingPublicKey: signingPublicKey,
                signingPrivateKey: signingPrivateKey,
                nextUpdateRevealValueEncodedString: nextUpdateRevealValueEncodedString
              });

            case 26:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function generateCreateOperation() {
      return _generateCreateOperation.apply(this, arguments);
    }

    return generateCreateOperation;
  }()
  /**
   * Generates a recover operation.
   */
  ;

  OperationGenerator.generateRecoverOperation =
  /*#__PURE__*/
  function () {
    var _generateRecoverOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(input) {
      var newSigningKeyId, _yield$Jwk$generateEd4, newRecoveryPublicKey, newRecoveryPrivateKey, _yield$OperationGener2, newSigningPublicKey, newSigningPrivateKey, _yield$OperationGener3, publicKeyToBeInDocument, services, _yield$OperationGener4, update_key, updatePrivateKey, operationJson, operationBuffer, recoverOperation;

      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              newSigningKeyId = 'newSigningKey';
              _context4.next = 3;
              return Jwk.generateEd25519KeyPair();

            case 3:
              _yield$Jwk$generateEd4 = _context4.sent;
              newRecoveryPublicKey = _yield$Jwk$generateEd4[0];
              newRecoveryPrivateKey = _yield$Jwk$generateEd4[1];
              _context4.next = 8;
              return OperationGenerator.generateKeyPair(newSigningKeyId);

            case 8:
              _yield$OperationGener2 = _context4.sent;
              newSigningPublicKey = _yield$OperationGener2[0];
              newSigningPrivateKey = _yield$OperationGener2[1];
              _context4.next = 13;
              return OperationGenerator.generateKeyPair('newKey');

            case 13:
              _yield$OperationGener3 = _context4.sent;
              publicKeyToBeInDocument = _yield$OperationGener3[0];
              services = OperationGenerator.generateServiceEndpoints(['serviceEndpointId123']); // Generate the next update and recover operation commitment hash reveal value pair.

              _context4.next = 18;
              return OperationGenerator.generateKeyPair('update_key');

            case 18:
              _yield$OperationGener4 = _context4.sent;
              update_key = _yield$OperationGener4[0];
              updatePrivateKey = _yield$OperationGener4[1];
              _context4.next = 23;
              return OperationGenerator.generateRecoverOperationRequest(input.didUniqueSuffix, input.recoveryPrivateKey, newRecoveryPublicKey, newSigningPublicKey, services, [publicKeyToBeInDocument]);

            case 23:
              operationJson = _context4.sent;
              operationBuffer = Buffer.from(JSON.stringify(operationJson));
              _context4.next = 27;
              return RecoverOperation.parse(operationBuffer);

            case 27:
              recoverOperation = _context4.sent;
              return _context4.abrupt("return", {
                recoverOperation: recoverOperation,
                operationBuffer: operationBuffer,
                recoveryPublicKey: newRecoveryPublicKey,
                recoveryPrivateKey: newRecoveryPrivateKey,
                signingPublicKey: newSigningPublicKey,
                signingPrivateKey: newSigningPrivateKey,
                update_key: update_key,
                updatePrivateKey: updatePrivateKey
              });

            case 29:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function generateRecoverOperation(_x4) {
      return _generateRecoverOperation.apply(this, arguments);
    }

    return generateRecoverOperation;
  }()
  /**
   * Generates an update operation that adds a new key.
   */
  ;

  OperationGenerator.generateUpdateOperation =
  /*#__PURE__*/
  function () {
    var _generateUpdateOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(didUniqueSuffix, updatePublicKey, updatePrivateKey) {
      var additionalKeyId, _yield$OperationGener5, additionalPublicKey, additionalPrivateKey, operationJson, operationBuffer, updateOperation;

      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              additionalKeyId = "additional-key";
              _context5.next = 3;
              return OperationGenerator.generateKeyPair(additionalKeyId);

            case 3:
              _yield$OperationGener5 = _context5.sent;
              additionalPublicKey = _yield$OperationGener5[0];
              additionalPrivateKey = _yield$OperationGener5[1];
              _context5.next = 8;
              return OperationGenerator.createUpdateOperationRequestForAddingAKey(didUniqueSuffix, updatePublicKey, updatePrivateKey, additionalPublicKey, common.Multihash.canonicalizeThenHashThenEncode(additionalPublicKey));

            case 8:
              operationJson = _context5.sent;
              operationBuffer = Buffer.from(JSON.stringify(operationJson));
              _context5.next = 12;
              return UpdateOperation.parse(operationBuffer);

            case 12:
              updateOperation = _context5.sent;
              return _context5.abrupt("return", {
                updateOperation: updateOperation,
                operationBuffer: operationBuffer,
                additionalKeyId: additionalKeyId,
                additionalPublicKey: additionalPublicKey,
                additionalPrivateKey: additionalPrivateKey,
                nextUpdateKey: additionalPublicKey.jwk
              });

            case 14:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    function generateUpdateOperation(_x5, _x6, _x7) {
      return _generateUpdateOperation.apply(this, arguments);
    }

    return generateUpdateOperation;
  }()
  /**
   * Creates a named anchored operation model from `OperationModel`.
   */
  ;

  OperationGenerator.createAnchoredOperationModelFromOperationModel = function createAnchoredOperationModelFromOperationModel(operationModel, transactionTime, transactionNumber, operationIndex) {
    var anchoredOperationModel = {
      didUniqueSuffix: operationModel.didUniqueSuffix,
      type: operationModel.type,
      operationBuffer: operationModel.operationBuffer,
      operationIndex: operationIndex,
      transactionNumber: transactionNumber,
      transactionTime: transactionTime
    };
    return anchoredOperationModel;
  }
  /**
   * Generates a create operation request.
   */
  ;

  OperationGenerator.generateCreateOperationRequest =
  /*#__PURE__*/
  function () {
    var _generateCreateOperationRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(recoveryPublicKey, updatePublicKey, otherPublicKeys, service_endpoints) {
      var document, patches, delta, deltaBuffer, delta_hash, suffixData, suffixDataEncodedString, deltaEncodedString, operation;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              document = {
                public_keys: otherPublicKeys,
                service_endpoints: service_endpoints
              };
              patches = [{
                action: 'replace',
                document: document
              }];
              delta = {
                update_commitment: common.Multihash.canonicalizeThenHashThenEncode(updatePublicKey),
                patches: patches
              };
              deltaBuffer = Buffer.from(JSON.stringify(delta));
              delta_hash = common.Encoder.encode(common.Multihash.hash(deltaBuffer));
              suffixData = {
                delta_hash: delta_hash,
                recovery_commitment: common.Multihash.canonicalizeThenHashThenEncode(recoveryPublicKey)
              };
              suffixDataEncodedString = common.Encoder.encode(JSON.stringify(suffixData));
              deltaEncodedString = common.Encoder.encode(deltaBuffer);
              operation = {
                type: common.OperationType.Create,
                suffix_data: suffixDataEncodedString,
                delta: deltaEncodedString
              };
              return _context6.abrupt("return", operation);

            case 10:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    function generateCreateOperationRequest(_x8, _x9, _x10, _x11) {
      return _generateCreateOperationRequest.apply(this, arguments);
    }

    return generateCreateOperationRequest;
  }()
  /**
   * Generates an update operation request.
   */
  ;

  OperationGenerator.generateUpdateOperationRequest =
  /*#__PURE__*/
  function () {
    var _generateUpdateOperationRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(didUniqueSuffix) {
      var _yield$OperationGener6, nextUpdateKey, nextUpdateCommitmentHash, anyNewSigningPublicKeyId, _yield$OperationGener7, anyNewSigningKey, patches, signingKeyId, _yield$OperationGener8, signingPublicKey, signingPrivateKey, request, buffer, updateOperation;

      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (didUniqueSuffix === undefined) {
                didUniqueSuffix = OperationGenerator.generateRandomHash();
              }

              _context7.next = 3;
              return OperationGenerator.generateKeyPair('nextUpdateKey');

            case 3:
              _yield$OperationGener6 = _context7.sent;
              nextUpdateKey = _yield$OperationGener6[0];
              nextUpdateCommitmentHash = common.Multihash.canonicalizeThenHashThenEncode(nextUpdateKey.jwk);
              anyNewSigningPublicKeyId = 'anyNewKey';
              _context7.next = 9;
              return OperationGenerator.generateKeyPair(anyNewSigningPublicKeyId);

            case 9:
              _yield$OperationGener7 = _context7.sent;
              anyNewSigningKey = _yield$OperationGener7[0];
              patches = [{
                action: 'add-public-keys',
                public_keys: [anyNewSigningKey]
              }];
              signingKeyId = 'anySigningKeyId';
              _context7.next = 15;
              return OperationGenerator.generateKeyPair(signingKeyId);

            case 15:
              _yield$OperationGener8 = _context7.sent;
              signingPublicKey = _yield$OperationGener8[0];
              signingPrivateKey = _yield$OperationGener8[1];
              _context7.next = 20;
              return OperationGenerator.createUpdateOperationRequest(didUniqueSuffix, signingPublicKey.jwk, signingPrivateKey, nextUpdateCommitmentHash, patches);

            case 20:
              request = _context7.sent;
              buffer = Buffer.from(JSON.stringify(request));
              _context7.next = 24;
              return UpdateOperation.parse(buffer);

            case 24:
              updateOperation = _context7.sent;
              return _context7.abrupt("return", {
                request: request,
                buffer: buffer,
                updateOperation: updateOperation
              });

            case 26:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    function generateUpdateOperationRequest(_x12) {
      return _generateUpdateOperationRequest.apply(this, arguments);
    }

    return generateUpdateOperationRequest;
  }()
  /**
   * Creates an update operation request.
   */
  ;

  OperationGenerator.createUpdateOperationRequest =
  /*#__PURE__*/
  function () {
    var _createUpdateOperationRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(didUniqueSuffix, updatePublicKey, updatePrivateKey, nextUpdateCommitmentHash, patches) {
      var delta, deltaJsonString, delta_hash, encodedDeltaString, signedDataPayloadObject, signedData, updateOperationRequest;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              delta = {
                patches: patches,
                update_commitment: nextUpdateCommitmentHash
              };
              deltaJsonString = JSON.stringify(delta);
              delta_hash = common.Encoder.encode(common.Multihash.hash(Buffer.from(deltaJsonString)));
              encodedDeltaString = common.Encoder.encode(deltaJsonString);
              signedDataPayloadObject = {
                update_key: updatePublicKey,
                delta_hash: delta_hash
              };
              _context8.next = 7;
              return OperationGenerator.signUsingEd25519(signedDataPayloadObject, updatePrivateKey);

            case 7:
              signedData = _context8.sent;
              updateOperationRequest = {
                type: common.OperationType.Update,
                did_suffix: didUniqueSuffix,
                delta: encodedDeltaString,
                signed_data: signedData
              };
              return _context8.abrupt("return", updateOperationRequest);

            case 10:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }));

    function createUpdateOperationRequest(_x13, _x14, _x15, _x16, _x17) {
      return _createUpdateOperationRequest.apply(this, arguments);
    }

    return createUpdateOperationRequest;
  }()
  /**
   * Generates a recover operation request.
   */
  ;

  OperationGenerator.generateRecoverOperationRequest =
  /*#__PURE__*/
  function () {
    var _generateRecoverOperationRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(didUniqueSuffix, recoveryPrivateKey, newRecoveryPublicKey, newSigningPublicKey, service_endpoints, public_keys) {
      var document, recoverOperation;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              document = {
                public_keys: public_keys,
                service_endpoints: service_endpoints
              };
              _context9.next = 3;
              return OperationGenerator.createRecoverOperationRequest(didUniqueSuffix, recoveryPrivateKey, newRecoveryPublicKey, common.Multihash.canonicalizeThenHashThenEncode(newSigningPublicKey.jwk), document);

            case 3:
              recoverOperation = _context9.sent;
              return _context9.abrupt("return", recoverOperation);

            case 5:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));

    function generateRecoverOperationRequest(_x18, _x19, _x20, _x21, _x22, _x23) {
      return _generateRecoverOperationRequest.apply(this, arguments);
    }

    return generateRecoverOperationRequest;
  }()
  /**
   * Creates a recover operation request.
   */
  ;

  OperationGenerator.createRecoverOperationRequest =
  /*#__PURE__*/
  function () {
    var _createRecoverOperationRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(didUniqueSuffix, recoveryPrivateKey, newRecoveryPublicKey, nextUpdateCommitmentHash, document) {
      var patches, delta, deltaBuffer, delta_hash, signedDataPayloadObject, signedData, deltaEncodedString, operation;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              patches = [{
                action: 'replace',
                document: document
              }];
              delta = {
                patches: patches,
                update_commitment: nextUpdateCommitmentHash
              };
              deltaBuffer = Buffer.from(JSON.stringify(delta));
              delta_hash = common.Encoder.encode(common.Multihash.hash(deltaBuffer));
              signedDataPayloadObject = {
                delta_hash: delta_hash,
                recovery_key: Jwk.getCurve25519PublicKey(recoveryPrivateKey),
                recovery_commitment: common.Multihash.canonicalizeThenHashThenEncode(newRecoveryPublicKey)
              };
              _context10.next = 7;
              return OperationGenerator.signUsingEd25519(signedDataPayloadObject, recoveryPrivateKey);

            case 7:
              signedData = _context10.sent;
              deltaEncodedString = common.Encoder.encode(deltaBuffer);
              operation = {
                type: common.OperationType.Recover,
                did_suffix: didUniqueSuffix,
                signed_data: signedData,
                delta: deltaEncodedString
              };
              return _context10.abrupt("return", operation);

            case 11:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }));

    function createRecoverOperationRequest(_x24, _x25, _x26, _x27, _x28) {
      return _createRecoverOperationRequest.apply(this, arguments);
    }

    return createRecoverOperationRequest;
  }()
  /**
   * Generates a deactivate operation request.
   */
  ;

  OperationGenerator.createDeactivateOperationRequest =
  /*#__PURE__*/
  function () {
    var _createDeactivateOperationRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(didUniqueSuffix, recoveryPrivateKey) {
      var signedDataPayloadObject, signedData, operation;
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              signedDataPayloadObject = {
                did_suffix: didUniqueSuffix,
                recovery_key: Jwk.getCurve25519PublicKey(recoveryPrivateKey)
              };
              _context11.next = 3;
              return OperationGenerator.signUsingEd25519(signedDataPayloadObject, recoveryPrivateKey);

            case 3:
              signedData = _context11.sent;
              operation = {
                type: common.OperationType.Deactivate,
                did_suffix: didUniqueSuffix,
                signed_data: signedData
              };
              return _context11.abrupt("return", operation);

            case 6:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }));

    function createDeactivateOperationRequest(_x29, _x30) {
      return _createDeactivateOperationRequest.apply(this, arguments);
    }

    return createDeactivateOperationRequest;
  }()
  /**
   * Generates a create operation request buffer.
   * @param nextRecoveryCommitmentHash The encoded commitment hash for the next recovery.
   * @param nextUpdateCommitmentHash The encoded commitment hash for the next update.
   */
  ;

  OperationGenerator.generateCreateOperationBuffer =
  /*#__PURE__*/
  function () {
    var _generateCreateOperationBuffer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(recoveryPublicKey, signingPublicKey, service_endpoints) {
      var operation;
      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return OperationGenerator.generateCreateOperationRequest(recoveryPublicKey, signingPublicKey.jwk, [signingPublicKey], service_endpoints);

            case 2:
              operation = _context12.sent;
              return _context12.abrupt("return", Buffer.from(JSON.stringify(operation)));

            case 4:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }));

    function generateCreateOperationBuffer(_x31, _x32, _x33) {
      return _generateCreateOperationBuffer.apply(this, arguments);
    }

    return generateCreateOperationBuffer;
  }()
  /**
   * Creates an update operation for adding a key.
   */
  ;

  OperationGenerator.createUpdateOperationRequestForAddingAKey =
  /*#__PURE__*/
  function () {
    var _createUpdateOperationRequestForAddingAKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(didUniqueSuffix, updatePublicKey, updatePrivateKey, newPublicKey, nextUpdateCommitmentHash) {
      var patches, updateOperationRequest;
      return runtime_1.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              patches = [{
                action: 'add-public-keys',
                public_keys: [newPublicKey]
              }];
              _context13.next = 3;
              return OperationGenerator.createUpdateOperationRequest(didUniqueSuffix, updatePublicKey, updatePrivateKey, nextUpdateCommitmentHash, patches);

            case 3:
              updateOperationRequest = _context13.sent;
              return _context13.abrupt("return", updateOperationRequest);

            case 5:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13);
    }));

    function createUpdateOperationRequestForAddingAKey(_x34, _x35, _x36, _x37, _x38) {
      return _createUpdateOperationRequestForAddingAKey.apply(this, arguments);
    }

    return createUpdateOperationRequestForAddingAKey;
  }()
  /**
   * Creates an update operation for adding and/or removing hub service endpoints.
   */
  ;

  OperationGenerator.createUpdateOperationRequestForHubEndpoints =
  /*#__PURE__*/
  function () {
    var _createUpdateOperationRequestForHubEndpoints = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(didUniqueSuffix, updatePublicKey, updatePrivateKey, nextUpdateCommitmentHash, idOfServiceEndpointToAdd, idsOfServiceEndpointToRemove) {
      var patches, patch, _patch, updateOperationRequest;

      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              patches = [];

              if (idOfServiceEndpointToAdd !== undefined) {
                patch = {
                  action: 'add-service-endpoints',
                  service_endpoints: OperationGenerator.generateServiceEndpoints([idOfServiceEndpointToAdd])
                };
                patches.push(patch);
              }

              if (idsOfServiceEndpointToRemove.length > 0) {
                _patch = {
                  action: 'remove-service-endpoints',
                  ids: idsOfServiceEndpointToRemove
                };
                patches.push(_patch);
              }

              _context14.next = 5;
              return OperationGenerator.createUpdateOperationRequest(didUniqueSuffix, updatePublicKey, updatePrivateKey, nextUpdateCommitmentHash, patches);

            case 5:
              updateOperationRequest = _context14.sent;
              return _context14.abrupt("return", updateOperationRequest);

            case 7:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14);
    }));

    function createUpdateOperationRequestForHubEndpoints(_x39, _x40, _x41, _x42, _x43, _x44) {
      return _createUpdateOperationRequestForHubEndpoints.apply(this, arguments);
    }

    return createUpdateOperationRequestForHubEndpoints;
  }()
  /**
   * Signs the given payload as a ed25519 compact JWS.
   */
  ;

  OperationGenerator.signUsingEd25519 =
  /*#__PURE__*/
  function () {
    var _signUsingEd = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(payload, privateKey) {
      var protectedHeader, compactJws;
      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              protectedHeader = {
                alg: 'EdDSA'
              };
              _context15.next = 3;
              return Jws.signAsCompactJws(payload, privateKey, protectedHeader);

            case 3:
              compactJws = _context15.sent;
              return _context15.abrupt("return", compactJws);

            case 5:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15);
    }));

    function signUsingEd25519(_x45, _x46) {
      return _signUsingEd.apply(this, arguments);
    }

    return signUsingEd25519;
  }()
  /**
   * Generates a Deactivate Operation data.
   */
  ;

  OperationGenerator.createDeactivateOperation =
  /*#__PURE__*/
  function () {
    var _createDeactivateOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(didUniqueSuffix, recoveryPrivateKey) {
      var operationRequest, operationBuffer, deactivateOperation;
      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return OperationGenerator.createDeactivateOperationRequest(didUniqueSuffix, recoveryPrivateKey);

            case 2:
              operationRequest = _context16.sent;
              operationBuffer = Buffer.from(JSON.stringify(operationRequest));
              _context16.next = 6;
              return DeactivateOperation.parse(operationBuffer);

            case 6:
              deactivateOperation = _context16.sent;
              return _context16.abrupt("return", {
                operationRequest: operationRequest,
                operationBuffer: operationBuffer,
                deactivateOperation: deactivateOperation
              });

            case 8:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16);
    }));

    function createDeactivateOperation(_x47, _x48) {
      return _createDeactivateOperation.apply(this, arguments);
    }

    return createDeactivateOperation;
  }()
  /**
   * Generates an array of service endpoints with specified ids
   * @param ids the id field in endpoint.
   */
  ;

  OperationGenerator.generateServiceEndpoints = function generateServiceEndpoints(ids) {
    var service_endpoints = [];

    for (var _iterator = _createForOfIteratorHelperLoose(ids), _step; !(_step = _iterator()).done;) {
      var id = _step.value;
      service_endpoints.push({
        id: id,
        type: 'someType',
        endpoint: 'https://www.url.com'
      });
    }

    return service_endpoints;
  };

  return OperationGenerator;
}();

/**
 * NOTE: Resolver cannot be versioned because it needs to be aware of `VersionManager` to fetch versioned operation processors.
 */

var Resolver = /*#__PURE__*/function () {
  function Resolver(versionManager, operationStore) {
    this.versionManager = versionManager;
    this.operationStore = operationStore;
  }
  /**
   * Resolve the given DID unique suffix to its latest DID state.
   * @param didUniqueSuffix The unique suffix of the DID to resolve. e.g. if 'did:sidetree:abc123' is the DID, the unique suffix would be 'abc123'
   * @returns Final DID state of the DID. Undefined if the unique suffix of the DID is not found or the DID state is not constructable.
   */


  var _proto = Resolver.prototype;

  _proto.resolve =
  /*#__PURE__*/
  function () {
    var _resolve = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(didUniqueSuffix) {
      var operations, operationsByType, didState, recoverAndDeactivateOperations, recoveryCommitValueToOperationMap, updateCommitValueToOperationMap;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              console.info("Resolving DID unique suffix '" + didUniqueSuffix + "'...");
              _context.next = 3;
              return this.operationStore.get(didUniqueSuffix);

            case 3:
              operations = _context.sent;
              operationsByType = Resolver.categorizeOperationsByType(operations); // Find and apply a valid create operation.

              _context.next = 7;
              return this.applyCreateOperation(operationsByType.createOperations);

            case 7:
              didState = _context.sent;

              if (!(didState === undefined)) {
                _context.next = 10;
                break;
              }

              return _context.abrupt("return", undefined);

            case 10:
              // Apply recovery/deactivate operations until an operation matching the next recovery commitment cannot be found.
              recoverAndDeactivateOperations = operationsByType.recoverOperations.concat(operationsByType.deactivateOperations);
              _context.next = 13;
              return this.constructCommitValueToOperationLookupMap(recoverAndDeactivateOperations);

            case 13:
              recoveryCommitValueToOperationMap = _context.sent;
              _context.next = 16;
              return this.applyRecoverAndDeactivateOperations(didState, recoveryCommitValueToOperationMap);

            case 16:
              didState = _context.sent;

              if (!(didState.nextRecoveryCommitmentHash === undefined)) {
                _context.next = 19;
                break;
              }

              return _context.abrupt("return", didState);

            case 19:
              _context.next = 21;
              return this.constructCommitValueToOperationLookupMap(operationsByType.updateOperations);

            case 21:
              updateCommitValueToOperationMap = _context.sent;
              _context.next = 24;
              return this.applyUpdateOperations(didState, updateCommitValueToOperationMap);

            case 24:
              didState = _context.sent;
              return _context.abrupt("return", didState);

            case 26:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function resolve(_x) {
      return _resolve.apply(this, arguments);
    }

    return resolve;
  }();

  Resolver.categorizeOperationsByType = function categorizeOperationsByType(operations) {
    var createOperations = [];
    var recoverOperations = [];
    var updateOperations = [];
    var deactivateOperations = [];

    for (var _iterator = _createForOfIteratorHelperLoose(operations), _step; !(_step = _iterator()).done;) {
      var operation = _step.value;

      if (operation.type === common.OperationType.Create) {
        createOperations.push(operation);
      } else if (operation.type === common.OperationType.Recover) {
        recoverOperations.push(operation);
      } else if (operation.type === common.OperationType.Update) {
        updateOperations.push(operation);
      } else {
        // This is a deactivate operation.
        deactivateOperations.push(operation);
      }
    }

    return {
      createOperations: createOperations,
      recoverOperations: recoverOperations,
      updateOperations: updateOperations,
      deactivateOperations: deactivateOperations
    };
  }
  /**
   * Iterate through all duplicates of creates until we can construct an initial DID state (some creates maybe incomplete. eg. without `delta`).
   */
  ;

  _proto.applyCreateOperation =
  /*#__PURE__*/
  function () {
    var _applyCreateOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(createOperations) {
      var didState, _iterator2, _step2, createOperation;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelperLoose(createOperations);

            case 1:
              if ((_step2 = _iterator2()).done) {
                _context2.next = 10;
                break;
              }

              createOperation = _step2.value;
              _context2.next = 5;
              return this.applyOperation(createOperation, undefined);

            case 5:
              didState = _context2.sent;

              if (!(didState !== undefined)) {
                _context2.next = 8;
                break;
              }

              return _context2.abrupt("break", 10);

            case 8:
              _context2.next = 1;
              break;

            case 10:
              return _context2.abrupt("return", didState);

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function applyCreateOperation(_x2) {
      return _applyCreateOperation.apply(this, arguments);
    }

    return applyCreateOperation;
  }()
  /**
   * Apply recovery/deactivate operations until an operation matching the next recovery commitment cannot be found.
   */
  ;

  _proto.applyRecoverAndDeactivateOperations =
  /*#__PURE__*/
  function () {
    var _applyRecoverAndDeactivateOperations = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(startingDidState, commitValueToOperationMap) {
      var didState, operationsWithCorrectRevealValue, newDidState;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              didState = startingDidState;

            case 1:
              if (!commitValueToOperationMap.has(didState.nextRecoveryCommitmentHash)) {
                _context3.next = 14;
                break;
              }

              operationsWithCorrectRevealValue = commitValueToOperationMap.get(didState.nextRecoveryCommitmentHash); // Sort using blockchain time.

              operationsWithCorrectRevealValue = operationsWithCorrectRevealValue.sort(function (a, b) {
                return a.transactionNumber - b.transactionNumber;
              });
              _context3.next = 6;
              return this.applyFirstValidOperation(operationsWithCorrectRevealValue, didState);

            case 6:
              newDidState = _context3.sent;

              if (!(newDidState === undefined)) {
                _context3.next = 9;
                break;
              }

              return _context3.abrupt("break", 14);

            case 9:
              // We reach here if we have successfully computed a new DID state.
              didState = newDidState; // If the previous applied operation is a deactivate. No need to continue further.

              if (!(didState.nextRecoveryCommitmentHash === undefined)) {
                _context3.next = 12;
                break;
              }

              return _context3.abrupt("return", didState);

            case 12:
              _context3.next = 1;
              break;

            case 14:
              return _context3.abrupt("return", didState);

            case 15:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function applyRecoverAndDeactivateOperations(_x3, _x4) {
      return _applyRecoverAndDeactivateOperations.apply(this, arguments);
    }

    return applyRecoverAndDeactivateOperations;
  }()
  /**
   * Apply update operations until an operation matching the next update commitment cannot be found.
   */
  ;

  _proto.applyUpdateOperations =
  /*#__PURE__*/
  function () {
    var _applyUpdateOperations = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(startingDidState, commitValueToOperationMap) {
      var didState, operationsWithCorrectRevealValue, newDidState;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              didState = startingDidState;

            case 1:
              if (!commitValueToOperationMap.has(didState.nextUpdateCommitmentHash)) {
                _context4.next = 12;
                break;
              }

              operationsWithCorrectRevealValue = commitValueToOperationMap.get(didState.nextUpdateCommitmentHash); // Sort using blockchain time.

              operationsWithCorrectRevealValue = operationsWithCorrectRevealValue.sort(function (a, b) {
                return a.transactionNumber - b.transactionNumber;
              });
              _context4.next = 6;
              return this.applyFirstValidOperation(operationsWithCorrectRevealValue, didState);

            case 6:
              newDidState = _context4.sent;

              if (!(newDidState === undefined)) {
                _context4.next = 9;
                break;
              }

              return _context4.abrupt("break", 12);

            case 9:
              // We reach here if we have successfully computed a new DID state.
              didState = newDidState;
              _context4.next = 1;
              break;

            case 12:
              return _context4.abrupt("return", didState);

            case 13:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function applyUpdateOperations(_x5, _x6) {
      return _applyUpdateOperations.apply(this, arguments);
    }

    return applyUpdateOperations;
  }()
  /**
   * Applies the given operation to the given DID state.
   * @param operation The operation to be applied.
   * @param didState The DID state to apply the operation on top of.
   * @returns The resultant `DidState`. The given DID state is return if the given operation cannot be applied.
   */
  ;

  _proto.applyOperation =
  /*#__PURE__*/
  function () {
    var _applyOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(operation, didState) {
      var appliedDidState, operationProcessor;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              appliedDidState = didState; // NOTE: MUST NOT throw error, else a bad operation can be used to denial resolution for a DID.

              _context5.prev = 1;
              operationProcessor = this.versionManager.getOperationProcessor(operation.transactionTime);
              _context5.next = 5;
              return operationProcessor.apply(operation, appliedDidState);

            case 5:
              appliedDidState = _context5.sent;
              _context5.next = 11;
              break;

            case 8:
              _context5.prev = 8;
              _context5.t0 = _context5["catch"](1);
              console.log("Skipped bad operation for DID " + operation.didUniqueSuffix + " at time " + operation.transactionTime + ". Error: " + common.SidetreeError.stringify(_context5.t0));

            case 11:
              return _context5.abrupt("return", appliedDidState);

            case 12:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this, [[1, 8]]);
    }));

    function applyOperation(_x7, _x8) {
      return _applyOperation.apply(this, arguments);
    }

    return applyOperation;
  }()
  /**
   * @returns The new DID State if a valid operation is applied, `undefined` otherwise.
   */
  ;

  _proto.applyFirstValidOperation =
  /*#__PURE__*/
  function () {
    var _applyFirstValidOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(operations, originalDidState) {
      var newDidState, _iterator3, _step3, operation;

      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              newDidState = originalDidState; // Stop as soon as an operation is applied successfully.

              _iterator3 = _createForOfIteratorHelperLoose(operations);

            case 2:
              if ((_step3 = _iterator3()).done) {
                _context6.next = 11;
                break;
              }

              operation = _step3.value;
              _context6.next = 6;
              return this.applyOperation(operation, newDidState);

            case 6:
              newDidState = _context6.sent;

              if (!(newDidState.lastOperationTransactionNumber !== originalDidState.lastOperationTransactionNumber)) {
                _context6.next = 9;
                break;
              }

              return _context6.abrupt("return", newDidState);

            case 9:
              _context6.next = 2;
              break;

            case 11:
              return _context6.abrupt("return", undefined);

            case 12:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function applyFirstValidOperation(_x9, _x10) {
      return _applyFirstValidOperation.apply(this, arguments);
    }

    return applyFirstValidOperation;
  }()
  /**
   * Constructs a single commit value -> operation lookup map by looping through each supported hash algorithm,
   * hashing each operations as key, then adding the result to a map.
   */
  ;

  _proto.constructCommitValueToOperationLookupMap =
  /*#__PURE__*/
  function () {
    var _constructCommitValueToOperationLookupMap = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(nonCreateOperations) {
      var commitValueToOperationMap, allSupportedHashAlgorithms, _iterator4, _step4, hashAlgorithm, _iterator5, _step5, operation, operationProcessor, revealValueBuffer, hashOfRevealValue;

      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              commitValueToOperationMap = new Map(); // Loop through each supported algorithm and hash each operation.

              allSupportedHashAlgorithms = this.versionManager.allSupportedHashAlgorithms;
              _iterator4 = _createForOfIteratorHelperLoose(allSupportedHashAlgorithms);

            case 3:
              if ((_step4 = _iterator4()).done) {
                _context7.next = 18;
                break;
              }

              hashAlgorithm = _step4.value;
              _iterator5 = _createForOfIteratorHelperLoose(nonCreateOperations);

            case 6:
              if ((_step5 = _iterator5()).done) {
                _context7.next = 16;
                break;
              }

              operation = _step5.value;
              operationProcessor = this.versionManager.getOperationProcessor(operation.transactionTime);
              _context7.next = 11;
              return operationProcessor.getRevealValue(operation);

            case 11:
              revealValueBuffer = _context7.sent;
              hashOfRevealValue = common.Multihash.hashThenEncode(revealValueBuffer, hashAlgorithm);

              if (commitValueToOperationMap.has(hashOfRevealValue)) {
                commitValueToOperationMap.get(hashOfRevealValue).push(operation);
              } else {
                commitValueToOperationMap.set(hashOfRevealValue, [operation]);
              }

            case 14:
              _context7.next = 6;
              break;

            case 16:
              _context7.next = 3;
              break;

            case 18:
              return _context7.abrupt("return", commitValueToOperationMap);

            case 19:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function constructCommitValueToOperationLookupMap(_x11) {
      return _constructCommitValueToOperationLookupMap.apply(this, arguments);
    }

    return constructCommitValueToOperationLookupMap;
  }();

  return Resolver;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/main/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Encapsulates the functionality to get the information about the service such as
 * version info.
 */
var ServiceInfoProvider = /*#__PURE__*/function () {
  function ServiceInfoProvider(serviceName) {
    this.serviceName = serviceName;
  }
  /**
   * Gets the service version from the package.json file.
   */


  var _proto = ServiceInfoProvider.prototype;

  _proto.getServiceVersion = function getServiceVersion() {
    return {
      name: this.serviceName,
      version: ServiceInfoProvider.packageJson.version
    };
  };

  return ServiceInfoProvider;
}();
ServiceInfoProvider.packageJson = /*#__PURE__*/require('../package.json');

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/main/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Encapsulates the functionality to calculate and verify the blockchain transaction fees.
 */

var FeeManager = /*#__PURE__*/function () {
  function FeeManager() {}

  /**
   * Converts the normalized fee (returned by the blockchain) into the transaction fee to be paid when writing
   * the current transaction.
   *
   * @param normalizedFee The normalized fee for the current transaction.
   * @param numberOfOperations The number of operations to write.
   * @param feeMarkupFactor Markup to be added to the calculated fee.
   *
   * @throws if the number of operations are <= 0.
   */
  FeeManager.computeMinimumTransactionFee = function computeMinimumTransactionFee(normalizedFee, numberOfOperations) {
    if (numberOfOperations <= 0) {
      throw new common.SidetreeError(common.ErrorCode.OperationCountLessThanZero, "Fee cannot be calculated for the given number of operations: " + numberOfOperations);
    }

    var feePerOperation = normalizedFee * common.protocolParameters.normalizedFeeToPerOperationFeeMultiplier;
    var feeForAllOperations = feePerOperation * numberOfOperations; // If our calculated-fee is lower than the normalized fee (which can happen if the number of operations is
    // very low) then the calculated-fee will be ignored by the blockchain miners ... so make sure that we
    // return at-least the normalized fee.

    var transactionFee = Math.max(feeForAllOperations, normalizedFee);
    return transactionFee;
  }
  /**
   * Verifies that the fee paid for the given transaction is valid; throws if it is not valid.
   *
   * @param transactionFeePaid The actual fee paid for that transaction.
   * @param numberOfOperations The number of operations written.
   * @param normalizedFee The normalized fee for that transaction.
   *
   * @throws if the number of operations is <= 0; if the feepaid is invalid.
   */
  ;

  FeeManager.verifyTransactionFeeAndThrowOnError = function verifyTransactionFeeAndThrowOnError(transactionFeePaid, numberOfOperations, normalizedFee) {
    // If there are no operations written then someone wrote incorrect data and we are going to throw
    if (numberOfOperations <= 0) {
      throw new common.SidetreeError(common.ErrorCode.OperationCountLessThanZero, "The number of operations: " + numberOfOperations + " must be greater than 0");
    }

    if (transactionFeePaid < normalizedFee) {
      throw new common.SidetreeError(common.ErrorCode.TransactionFeePaidLessThanNormalizedFee, "The actual fee paid: " + transactionFeePaid + " should be greater than or equal to the normalized fee: " + normalizedFee);
    }

    var actualFeePerOperation = transactionFeePaid / numberOfOperations;
    var expectedFeePerOperation = normalizedFee * common.protocolParameters.normalizedFeeToPerOperationFeeMultiplier;

    if (actualFeePerOperation < expectedFeePerOperation) {
      throw new common.SidetreeError(common.ErrorCode.TransactionFeePaidInvalid, "The actual fee paid: " + transactionFeePaid + " per number of operations: " + numberOfOperations + " should be at least " + expectedFeePerOperation + ".");
    }
  };

  return FeeManager;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/main/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Encapsulates the functionality to compute and verify the value time lock amounts.
 */

var ValueTimeLockVerifier = /*#__PURE__*/function () {
  function ValueTimeLockVerifier() {}

  /**
   * Calculates the maximum number of operations allowed to be written for the given lock information. If
   * there is no lock then it returns the number of operations which do not require a lock.
   *
   * @param valueTimeLock The lock object if exists
   * @param versionMetadataFetcher The mapper from transaction time to version metadata
   */
  ValueTimeLockVerifier.calculateMaxNumberOfOperationsAllowed = function calculateMaxNumberOfOperationsAllowed(valueTimeLock, versionMetadataFetcher) {
    if (valueTimeLock === undefined) {
      return common.protocolParameters.maxNumberOfOperationsForNoValueTimeLock;
    }

    var versionMetadata = versionMetadataFetcher.getVersionMetadata(valueTimeLock.lockTransactionTime);
    var normalizedFeeToPerOperationFeeMultiplier = versionMetadata.normalizedFeeToPerOperationFeeMultiplier;
    var valueTimeLockAmountMultiplier = versionMetadata.valueTimeLockAmountMultiplier; // Using the following formula:
    //  requiredLockAmount = normalizedfee * normalizedFeeMultipier * numberOfOps * valueTimeLockMultiplier
    //
    // We are going to find the numberOfOps given the requiredLockAmount

    var feePerOperation = valueTimeLock.normalizedFee * normalizedFeeToPerOperationFeeMultiplier;
    var numberOfOpsAllowed = valueTimeLock.amountLocked / (feePerOperation * valueTimeLockAmountMultiplier); // Make sure that we are returning an integer; rounding down to make sure that we are not going above
    // the max limit.

    var numberOfOpsAllowedInt = Math.floor(numberOfOpsAllowed); // Return at least the 'free' operations

    return Math.max(numberOfOpsAllowedInt, common.protocolParameters.maxNumberOfOperationsForNoValueTimeLock);
  }
  /**
   * Verifies that the value lock object (amount, transaction time range) is correct for the specified number
   * of operations.
   *
   * @param valueTimeLock The value time lock object used for verificiation.
   * @param numberOfOperations The target number of operations.
   * @param sidetreeTransactionTime The transaction time where the operations were written.
   * @param sidetreeTransactionWriter The writer of the transaction.
   * @param versionMetadataFetcher The mapper from transaction time to version metadata
   */
  ;

  ValueTimeLockVerifier.verifyLockAmountAndThrowOnError = function verifyLockAmountAndThrowOnError(valueTimeLock, numberOfOperations, sidetreeTransactionTime, sidetreeTransactionWriter, versionMetadataFetcher) {
    // If the number of written operations were under the free limit then there's nothing to check
    if (numberOfOperations <= common.protocolParameters.maxNumberOfOperationsForNoValueTimeLock) {
      return;
    }

    if (valueTimeLock) {
      // Check the lock owner
      if (valueTimeLock.owner !== sidetreeTransactionWriter) {
        throw new common.SidetreeError(common.ErrorCode.ValueTimeLockVerifierTransactionWriterLockOwnerMismatch, "Sidetree transaction writer: " + sidetreeTransactionWriter + " - Lock owner: " + valueTimeLock.owner);
      } // Check the lock duration


      if (sidetreeTransactionTime < valueTimeLock.lockTransactionTime || sidetreeTransactionTime >= valueTimeLock.unlockTransactionTime) {
        throw new common.SidetreeError(common.ErrorCode.ValueTimeLockVerifierTransactionTimeOutsideLockRange, // tslint:disable-next-line: max-line-length
        "Sidetree transaction block: " + sidetreeTransactionTime + "; lock start time: " + valueTimeLock.lockTransactionTime + "; unlock time: " + valueTimeLock.unlockTransactionTime);
      }
    }

    var maxNumberOfOpsAllowed = this.calculateMaxNumberOfOperationsAllowed(valueTimeLock, versionMetadataFetcher);

    if (numberOfOperations > maxNumberOfOpsAllowed) {
      throw new common.SidetreeError(common.ErrorCode.ValueTimeLockVerifierInvalidNumberOfOperations, "Max number of ops allowed: " + maxNumberOfOpsAllowed + "; actual number of ops: " + numberOfOperations);
    }
  };

  return ValueTimeLockVerifier;
}();

/**
 * Implementation of the `ITransactionProcessor`.
 */

var TransactionProcessor = /*#__PURE__*/function () {
  function TransactionProcessor(downloadManager, operationStore, blockchain, versionMetadataFetcher) {
    this.downloadManager = downloadManager;
    this.operationStore = operationStore;
    this.blockchain = blockchain;
    this.versionMetadataFetcher = versionMetadataFetcher;
  }

  var _proto = TransactionProcessor.prototype;

  _proto.processTransaction = /*#__PURE__*/function () {
    var _processTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(transaction) {
      var anchoredData, anchorFile, mapFile, chunkFileModel, operations;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              // Decode the anchor string.
              anchoredData = common.AnchoredDataSerializer.deserialize(transaction.anchorString); // Verify enough fee paid.

              FeeManager.verifyTransactionFeeAndThrowOnError(transaction.transactionFeePaid, anchoredData.numberOfOperations, transaction.normalizedTransactionFee); // Download and verify anchor file.

              _context.next = 5;
              return this.downloadAndVerifyAnchorFile(transaction, anchoredData.anchorFileHash, anchoredData.numberOfOperations);

            case 5:
              anchorFile = _context.sent;
              _context.next = 8;
              return this.downloadAndVerifyMapFile(anchorFile, anchoredData.numberOfOperations);

            case 8:
              mapFile = _context.sent;
              _context.next = 11;
              return this.downloadAndVerifyChunkFile(mapFile);

            case 11:
              chunkFileModel = _context.sent;
              _context.next = 14;
              return this.composeAnchoredOperationModels(transaction, anchorFile, mapFile, chunkFileModel);

            case 14:
              operations = _context.sent;
              _context.next = 17;
              return this.operationStore.put(operations);

            case 17:
              return _context.abrupt("return", true);

            case 20:
              _context.prev = 20;
              _context.t0 = _context["catch"](0);

              if (!(_context.t0 instanceof common.SidetreeError)) {
                _context.next = 29;
                break;
              }

              if (!(_context.t0.code === common.ErrorCode.CasNotReachable || _context.t0.code === common.ErrorCode.CasFileNotFound)) {
                _context.next = 25;
                break;
              }

              return _context.abrupt("return", false);

            case 25:
              console.info("Ignoring error: " + _context.t0.message);
              return _context.abrupt("return", true);

            case 29:
              console.error("Unexpected error processing transaction, MUST investigate and fix: " + _context.t0.message);
              return _context.abrupt("return", false);

            case 31:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[0, 20]]);
    }));

    function processTransaction(_x) {
      return _processTransaction.apply(this, arguments);
    }

    return processTransaction;
  }()
  /**
   * @param batchSize The size of the batch in number of operations.
   */
  ;

  _proto.downloadAndVerifyAnchorFile =
  /*#__PURE__*/
  function () {
    var _downloadAndVerifyAnchorFile = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(transaction, anchorFileHash, paidOperationCount) {
      var fileBuffer, anchorFile, operationCountInAnchorFile, valueTimeLock;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(paidOperationCount > common.protocolParameters.maxOperationsPerBatch)) {
                _context2.next = 2;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.TransactionProcessorPaidOperationCountExceedsLimit, "Paid batch size of " + paidOperationCount + " operations exceeds the allowed limit of " + common.protocolParameters.maxOperationsPerBatch + ".");

            case 2:
              console.info("Downloading anchor file '" + anchorFileHash + "', max file size limit " + common.protocolParameters.maxAnchorFileSizeInBytes + " bytes...");
              _context2.next = 5;
              return this.downloadFileFromCas(anchorFileHash, common.protocolParameters.maxAnchorFileSizeInBytes);

            case 5:
              fileBuffer = _context2.sent;
              _context2.next = 8;
              return AnchorFile.parse(fileBuffer);

            case 8:
              anchorFile = _context2.sent;
              operationCountInAnchorFile = anchorFile.didUniqueSuffixes.length;

              if (!(operationCountInAnchorFile > paidOperationCount)) {
                _context2.next = 12;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.AnchorFileOperationCountExceededPaidLimit, "Operation count " + operationCountInAnchorFile + " in anchor file exceeded limit of : " + paidOperationCount);

            case 12:
              if (!anchorFile.model.writer_lock_id) {
                _context2.next = 18;
                break;
              }

              _context2.next = 15;
              return this.blockchain.getValueTimeLock(anchorFile.model.writer_lock_id);

            case 15:
              _context2.t0 = _context2.sent;
              _context2.next = 19;
              break;

            case 18:
              _context2.t0 = undefined;

            case 19:
              valueTimeLock = _context2.t0;
              ValueTimeLockVerifier.verifyLockAmountAndThrowOnError(valueTimeLock, paidOperationCount, transaction.transactionTime, transaction.writer, this.versionMetadataFetcher);
              return _context2.abrupt("return", anchorFile);

            case 22:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function downloadAndVerifyAnchorFile(_x2, _x3, _x4) {
      return _downloadAndVerifyAnchorFile.apply(this, arguments);
    }

    return downloadAndVerifyAnchorFile;
  }()
  /**
   * NOTE: In order to be forward-compatable with data-pruning feature,
   * we must continue to process the operations declared in the anchor file even if the map/chunk file is invalid.
   * This means that this method MUST ONLY throw errors that are retryable (e.g. network or file not found errors),
   * It is a design choice to hide the complexity of map file downloading and construction within this method,
   * instead of throwing errors and letting the caller handle them.
   * @returns `MapFile` if downloaded file is valid; `undefined` otherwise.
   * @throws SidetreeErrors that are retryable.
   */
  ;

  _proto.downloadAndVerifyMapFile =
  /*#__PURE__*/
  function () {
    var _downloadAndVerifyMapFile = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(anchorFile, paidOperationCount) {
      var anchorFileModel, fileBuffer, mapFile, operationCountInAnchorFile, maxPaidUpdateOperationCount, updateOperationCount;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              anchorFileModel = anchorFile.model;
              console.info("Downloading map file '" + anchorFileModel.map_file_uri + "', max file size limit " + common.protocolParameters.maxMapFileSizeInBytes + "...");
              _context3.next = 5;
              return this.downloadFileFromCas(anchorFileModel.map_file_uri, common.protocolParameters.maxMapFileSizeInBytes);

            case 5:
              fileBuffer = _context3.sent;
              _context3.next = 8;
              return MapFile.parse(fileBuffer);

            case 8:
              mapFile = _context3.sent;
              // Calulate the max paid update operation count.
              operationCountInAnchorFile = anchorFile.didUniqueSuffixes.length;
              maxPaidUpdateOperationCount = paidOperationCount - operationCountInAnchorFile; // If the actual update operation count is greater than the max paid update operation count, the map file is invalid.

              updateOperationCount = mapFile.updateOperations ? mapFile.updateOperations.length : 0;

              if (!(updateOperationCount > maxPaidUpdateOperationCount)) {
                _context3.next = 14;
                break;
              }

              return _context3.abrupt("return", undefined);

            case 14:
              if (ArrayMethods.areMutuallyExclusive(anchorFile.didUniqueSuffixes, mapFile.didUniqueSuffixes)) {
                _context3.next = 16;
                break;
              }

              return _context3.abrupt("return", undefined);

            case 16:
              return _context3.abrupt("return", mapFile);

            case 19:
              _context3.prev = 19;
              _context3.t0 = _context3["catch"](0);

              if (!(_context3.t0 instanceof common.SidetreeError)) {
                _context3.next = 27;
                break;
              }

              if (!(_context3.t0.code === common.ErrorCode.CasNotReachable || _context3.t0.code === common.ErrorCode.CasFileNotFound)) {
                _context3.next = 24;
                break;
              }

              throw _context3.t0;

            case 24:
              return _context3.abrupt("return", undefined);

            case 27:
              console.error("Unexpected error fetching map file " + anchorFile.model.map_file_uri + ", MUST investigate and fix: " + common.SidetreeError.stringify(_context3.t0));
              return _context3.abrupt("return", undefined);

            case 29:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this, [[0, 19]]);
    }));

    function downloadAndVerifyMapFile(_x5, _x6) {
      return _downloadAndVerifyMapFile.apply(this, arguments);
    }

    return downloadAndVerifyMapFile;
  }()
  /**
   * NOTE: In order to be forward-compatable with data-pruning feature,
   * we must continue to process the operations declared in the anchor file even if the map/chunk file is invalid.
   * This means that this method MUST ONLY throw errors that are retryable (e.g. network or file not found errors),
   * It is a design choice to hide the complexity of chunk file downloading and construction within this method,
   * instead of throwing errors and letting the caller handle them.
   * @returns `ChunkFileModel` if downloaded file is valid; `undefined` otherwise.
   * @throws SidetreeErrors that are retryable.
   */
  ;

  _proto.downloadAndVerifyChunkFile =
  /*#__PURE__*/
  function () {
    var _downloadAndVerifyChunkFile = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(mapFile) {
      var chunkFileHash, fileBuffer, chunkFileModel;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!(mapFile === undefined)) {
                _context4.next = 2;
                break;
              }

              return _context4.abrupt("return", undefined);

            case 2:
              _context4.prev = 2;
              chunkFileHash = mapFile.model.chunks[0].chunk_file_uri;
              console.info("Downloading chunk file '" + chunkFileHash + "', max size limit " + common.protocolParameters.maxChunkFileSizeInBytes + "...");
              _context4.next = 7;
              return this.downloadFileFromCas(chunkFileHash, common.protocolParameters.maxChunkFileSizeInBytes);

            case 7:
              fileBuffer = _context4.sent;
              _context4.next = 10;
              return ChunkFile.parse(fileBuffer);

            case 10:
              chunkFileModel = _context4.sent;
              return _context4.abrupt("return", chunkFileModel);

            case 14:
              _context4.prev = 14;
              _context4.t0 = _context4["catch"](2);

              if (!(_context4.t0 instanceof common.SidetreeError)) {
                _context4.next = 22;
                break;
              }

              if (!(_context4.t0.code === common.ErrorCode.CasNotReachable || _context4.t0.code === common.ErrorCode.CasFileNotFound)) {
                _context4.next = 19;
                break;
              }

              throw _context4.t0;

            case 19:
              return _context4.abrupt("return", undefined);

            case 22:
              console.error("Unexpected error fetching chunk file " + chunkFileHash + ", MUST investigate and fix: " + common.SidetreeError.stringify(_context4.t0));
              return _context4.abrupt("return", undefined);

            case 24:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this, [[2, 14]]);
    }));

    function downloadAndVerifyChunkFile(_x7) {
      return _downloadAndVerifyChunkFile.apply(this, arguments);
    }

    return downloadAndVerifyChunkFile;
  }();

  _proto.composeAnchoredOperationModels = /*#__PURE__*/function () {
    var _composeAnchoredOperationModels = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(transaction, anchorFile, mapFile, chunkFile) {
      var createOperations, recoverOperations, deactivateOperations, updateOperations, operations, patchedOperationBuffers, operationCountExcludingDeactivates, i, operation, operationJsonString, operationObject, patchedOperationBuffer, _i, _operation, _operationJsonString, _operationObject, _patchedOperationBuffer, anchoredOperationModels, _i2, _operation2, anchoredOperationModel;

      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              createOperations = anchorFile.createOperations;
              recoverOperations = anchorFile.recoverOperations;
              deactivateOperations = anchorFile.deactivateOperations;
              updateOperations = mapFile && mapFile.updateOperations ? mapFile.updateOperations : []; // Add the operations in the following order of types: create, recover, update, deactivate.

              operations = [];
              operations.push.apply(operations, createOperations);
              operations.push.apply(operations, recoverOperations);
              operations.push.apply(operations, updateOperations);
              operations.push.apply(operations, deactivateOperations); // If chunk file is found/given, we need to add `type` and `delta` from chunk file to each operation.
              // NOTE: there is no delta for deactivate operations.

              patchedOperationBuffers = [];

              if (!(chunkFile !== undefined)) {
                _context5.next = 26;
                break;
              }

              // TODO: https://github.com/decentralized-identity/sidetree/issues/442
              // Use actual operation request object instead of buffer.
              operationCountExcludingDeactivates = createOperations.length + recoverOperations.length + updateOperations.length;
              i = 0;

            case 13:
              if (!(i < operationCountExcludingDeactivates && i < chunkFile.deltas.length)) {
                _context5.next = 26;
                break;
              }

              operation = operations[i];
              operationJsonString = operation.operationBuffer.toString();
              _context5.next = 18;
              return JsonAsync.parse(operationJsonString);

            case 18:
              operationObject = _context5.sent;
              operationObject.type = operation.type;
              operationObject.delta = chunkFile.deltas[i];
              patchedOperationBuffer = Buffer.from(JSON.stringify(operationObject));
              patchedOperationBuffers.push(patchedOperationBuffer);

            case 23:
              i++;
              _context5.next = 13;
              break;

            case 26:
              _i = 0;

            case 27:
              if (!(_i < deactivateOperations.length)) {
                _context5.next = 39;
                break;
              }

              _operation = deactivateOperations[_i];
              _operationJsonString = _operation.operationBuffer.toString();
              _context5.next = 32;
              return JsonAsync.parse(_operationJsonString);

            case 32:
              _operationObject = _context5.sent;
              _operationObject.type = _operation.type;
              _patchedOperationBuffer = Buffer.from(JSON.stringify(_operationObject));
              patchedOperationBuffers.push(_patchedOperationBuffer);

            case 36:
              _i++;
              _context5.next = 27;
              break;

            case 39:
              // Add anchored timestamp to each operation.
              anchoredOperationModels = [];

              for (_i2 = 0; _i2 < operations.length; _i2++) {
                _operation2 = operations[_i2];
                anchoredOperationModel = {
                  didUniqueSuffix: _operation2.didUniqueSuffix,
                  type: _operation2.type,
                  operationBuffer: patchedOperationBuffers[_i2],
                  operationIndex: _i2,
                  transactionNumber: transaction.transactionNumber,
                  transactionTime: transaction.transactionTime
                };
                anchoredOperationModels.push(anchoredOperationModel);
              }

              return _context5.abrupt("return", anchoredOperationModels);

            case 42:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    function composeAnchoredOperationModels(_x8, _x9, _x10, _x11) {
      return _composeAnchoredOperationModels.apply(this, arguments);
    }

    return composeAnchoredOperationModels;
  }();

  _proto.downloadFileFromCas = /*#__PURE__*/function () {
    var _downloadFileFromCas = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(fileHash, maxFileSizeInBytes) {
      var fileFetchResult;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              console.info("Downloading file '" + fileHash + "', max size limit " + maxFileSizeInBytes + "...");
              _context6.next = 3;
              return this.downloadManager.download(fileHash, maxFileSizeInBytes);

            case 3:
              fileFetchResult = _context6.sent;

              if (!(fileFetchResult.code === common.FetchResultCode.InvalidHash)) {
                _context6.next = 6;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.CasFileHashNotValid, "File hash '" + fileHash + "' is not a valid hash.");

            case 6:
              if (!(fileFetchResult.code === common.FetchResultCode.MaxSizeExceeded)) {
                _context6.next = 8;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.CasFileTooLarge, "File '" + fileHash + "' exceeded max size limit of " + maxFileSizeInBytes + " bytes.");

            case 8:
              if (!(fileFetchResult.code === common.FetchResultCode.NotAFile)) {
                _context6.next = 10;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.CasFileNotAFile, "File hash '" + fileHash + "' points to a content that is not a file.");

            case 10:
              if (!(fileFetchResult.code === common.FetchResultCode.CasNotReachable)) {
                _context6.next = 12;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.CasNotReachable, "CAS not reachable for file '" + fileHash + "'.");

            case 12:
              if (!(fileFetchResult.code === common.FetchResultCode.NotFound)) {
                _context6.next = 14;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.CasFileNotFound, "File '" + fileHash + "' not found.");

            case 14:
              console.info("File '" + fileHash + "' of size " + fileFetchResult.content.length + " downloaded.");
              return _context6.abrupt("return", fileFetchResult.content);

            case 16:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function downloadFileFromCas(_x12, _x13) {
      return _downloadFileFromCas.apply(this, arguments);
    }

    return downloadFileFromCas;
  }();

  return TransactionProcessor;
}();

/**
 * rate limits how many operations is valid per block
 */

var TransactionSelector = /*#__PURE__*/function () {
  function TransactionSelector(transactionStore) {
    this.transactionStore = transactionStore;
    this.maxNumberOfOperationsPerBlock = common.protocolParameters.maxNumberOfOperationsPerTransactionTime;
    this.maxNumberOfTransactionsPerBlock = common.protocolParameters.maxNumberOfTransactionsPerTransactionTime;
  }

  TransactionSelector.getTransactionPriorityQueue = function getTransactionPriorityQueue() {
    var comparator = function comparator(a, b) {
      // higher fee comes first. If fees are the same, earlier transaction comes first
      return a.transactionFeePaid - b.transactionFeePaid || b.transactionNumber - a.transactionNumber;
    };

    return new PriorityQueue({
      comparator: comparator
    });
  }
  /**
   * Returns an array of transactions that should be processed. Ranked by highest fee paid per transaction and up to the
   * max number of operations per block
   * @param transactions The transactions that should be ranked and considered to process
   */
  ;

  var _proto = TransactionSelector.prototype;

  _proto.selectQualifiedTransactions =
  /*#__PURE__*/
  function () {
    var _selectQualifiedTransactions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(transactions) {
      var transactionsPriorityQueue, currentTransactionTime, _yield$this$getNumber, numberOfOperations, numberOfTransactions, numberOfOperationsToQualify, numberOfTransactionsToQualify, transactionsToReturn;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (transactions.length) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", []);

            case 2:
              transactionsPriorityQueue = TransactionSelector.getTransactionPriorityQueue();
              currentTransactionTime = transactions[0].transactionTime;
              TransactionSelector.validateTransactions(transactions, currentTransactionTime);
              TransactionSelector.enqueueFirstTransactionFromEachWriter(transactions, currentTransactionTime, transactionsPriorityQueue);
              _context.next = 8;
              return this.getNumberOfOperationsAndTransactionsAlreadyInTransactionTime(currentTransactionTime);

            case 8:
              _yield$this$getNumber = _context.sent;
              numberOfOperations = _yield$this$getNumber[0];
              numberOfTransactions = _yield$this$getNumber[1];
              numberOfOperationsToQualify = this.maxNumberOfOperationsPerBlock - numberOfOperations;
              numberOfTransactionsToQualify = this.maxNumberOfTransactionsPerBlock - numberOfTransactions;
              transactionsToReturn = TransactionSelector.getHighestFeeTransactionsFromCurrentTransactionTime(numberOfOperationsToQualify, numberOfTransactionsToQualify, transactionsPriorityQueue);
              return _context.abrupt("return", transactionsToReturn);

            case 15:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function selectQualifiedTransactions(_x) {
      return _selectQualifiedTransactions.apply(this, arguments);
    }

    return selectQualifiedTransactions;
  }();

  TransactionSelector.validateTransactions = function validateTransactions(transactions, currentTransactionTime) {
    for (var _iterator = _createForOfIteratorHelperLoose(transactions), _step; !(_step = _iterator()).done;) {
      var transaction = _step.value;

      // expect all transactions to be in the same transaction time
      if (transaction.transactionTime !== currentTransactionTime) {
        throw new common.SidetreeError(common.ErrorCode.TransactionsNotInSameBlock, 'transaction must be in the same block to perform rate limiting, investigate and fix');
      }
    }
  };

  TransactionSelector.enqueueFirstTransactionFromEachWriter = function enqueueFirstTransactionFromEachWriter(transactions, currentTransactionTime, transactionsPriorityQueue) {
    var writerToTransactionNumberMap = new Map(); // if multiple transactions have the same writer, take the first one in the array and enqueue into transactionPriorityQueue

    for (var _iterator2 = _createForOfIteratorHelperLoose(transactions), _step2; !(_step2 = _iterator2()).done;) {
      var transaction = _step2.value;

      // only 1 transaction is allowed per writer
      if (writerToTransactionNumberMap.has(transaction.writer)) {
        var acceptedTransactionNumber = writerToTransactionNumberMap.get(transaction.writer); // tslint:disable-next-line:max-line-length

        console.info("Multiple transactions found in transaction time " + currentTransactionTime + " from writer " + transaction.writer + ", considering transaction " + acceptedTransactionNumber + " and ignoring " + transaction.transactionNumber);
      } else {
        transactionsPriorityQueue.push(transaction);
        writerToTransactionNumberMap.set(transaction.writer, transaction.transactionNumber);
      }
    }
  };

  _proto.getNumberOfOperationsAndTransactionsAlreadyInTransactionTime = /*#__PURE__*/function () {
    var _getNumberOfOperationsAndTransactionsAlreadyInTransactionTime = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(transactionTime) {
      var transactions, numberOfOperations, _iterator3, _step3, transaction, numOfOperationsInCurrentTransaction, numberOfTransactions;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.transactionStore.getTransactionsStartingFrom(transactionTime, transactionTime);

            case 2:
              transactions = _context2.sent;
              numberOfOperations = 0;

              if (transactions) {
                for (_iterator3 = _createForOfIteratorHelperLoose(transactions); !(_step3 = _iterator3()).done;) {
                  transaction = _step3.value;

                  try {
                    numOfOperationsInCurrentTransaction = common.AnchoredDataSerializer.deserialize(transaction.anchorString).numberOfOperations;
                    numberOfOperations += numOfOperationsInCurrentTransaction;
                  } catch (e) {
                    console.debug("Error thrown in TransactionSelector: " + JSON.stringify(e, Object.getOwnPropertyNames(e)));
                    console.info("Transaction with anchor string " + transaction.anchorString + " not considered as selected.");
                  }
                }
              }

              numberOfTransactions = transactions ? transactions.length : 0;
              return _context2.abrupt("return", [numberOfOperations, numberOfTransactions]);

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getNumberOfOperationsAndTransactionsAlreadyInTransactionTime(_x2) {
      return _getNumberOfOperationsAndTransactionsAlreadyInTransactionTime.apply(this, arguments);
    }

    return getNumberOfOperationsAndTransactionsAlreadyInTransactionTime;
  }()
  /**
   * Given transactions within a block, return the ones that should be processed.
   */
  ;

  TransactionSelector.getHighestFeeTransactionsFromCurrentTransactionTime = function getHighestFeeTransactionsFromCurrentTransactionTime(numberOfOperationsToQualify, numberOfTransactionsToQualify, transactionsPriorityQueue) {
    var numberOfOperationsSeen = 0;
    var transactionsToReturn = [];

    while (transactionsToReturn.length < numberOfTransactionsToQualify && numberOfOperationsSeen < numberOfOperationsToQualify && transactionsPriorityQueue.length > 0) {
      var currentTransaction = transactionsPriorityQueue.pop();

      try {
        var numOfOperationsInCurrentTransaction = common.AnchoredDataSerializer.deserialize(currentTransaction.anchorString).numberOfOperations;
        numberOfOperationsSeen += numOfOperationsInCurrentTransaction;

        if (numberOfOperationsSeen <= numberOfOperationsToQualify) {
          transactionsToReturn.push(currentTransaction);
        }
      } catch (e) {
        console.debug("Error thrown in TransactionSelector: " + JSON.stringify(e, Object.getOwnPropertyNames(e)));
        console.info("Transaction with anchor string " + currentTransaction.anchorString + " not selected");
      }
    } // sort based on transaction number ascending


    return transactionsToReturn;
  };

  return TransactionSelector;
}();

/*
 * The code in this file originated from
 * @see https://github.com/decentralized-identity/sidetree
 * For the list of changes that was made to the original code
 * @see https://github.com/transmute-industries/sidetree.js/blob/main/reference-implementation-changes.md
 *
 * Copyright 2020 - Transmute Industries Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Abstraction for colored logs.
 */

var LogColor = function LogColor() {};
LogColor.lightBlue = /*#__PURE__*/chalk.hex('#75b0eb');
/** Method for logging in green. */

LogColor.green = chalk.green;
/** Method for logging in yellow. */

LogColor.yellow = chalk.yellow;

/**
 * Implementation of the `IBatchWriter`.
 */

var BatchWriter = /*#__PURE__*/function () {
  function BatchWriter(operationQueue, blockchain, cas, versionMetadataFetcher) {
    this.operationQueue = operationQueue;
    this.blockchain = blockchain;
    this.cas = cas;
    this.versionMetadataFetcher = versionMetadataFetcher;
  }

  var _proto = BatchWriter.prototype;

  _proto.write = /*#__PURE__*/function () {
    var _write = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      var normalizedFee, currentLock, numberOfOpsAllowed, queuedOperations, numberOfOperations, operationModels, createOperations, recoverOperations, updateOperations, deactivateOperations, chunkFileBuffer, chunkFileHash, mapFileBuffer, mapFileHash, writerLockId, anchorFileBuffer, anchorFileHash, dataToBeAnchored, stringToWriteToBlockchain, fee;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.blockchain.getFee(this.blockchain.approximateTime.time);

            case 2:
              normalizedFee = _context2.sent;
              _context2.next = 5;
              return this.blockchain.getWriterValueTimeLock();

            case 5:
              currentLock = _context2.sent;
              numberOfOpsAllowed = this.getNumberOfOperationsAllowed(currentLock); // Get the batch of operations to be anchored on the blockchain.

              _context2.next = 9;
              return this.operationQueue.peek(numberOfOpsAllowed);

            case 9:
              queuedOperations = _context2.sent;
              numberOfOperations = queuedOperations.length; // Do nothing if there is nothing to batch together.

              if (!(queuedOperations.length === 0)) {
                _context2.next = 14;
                break;
              }

              console.info("No queued operations to batch.");
              return _context2.abrupt("return");

            case 14:
              console.info(LogColor.lightBlue("Batch size = " + LogColor.green("" + numberOfOperations)));
              _context2.next = 17;
              return Promise.all(queuedOperations.map( /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(queuedOperation) {
                  return runtime_1.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          return _context.abrupt("return", Operation.parse(queuedOperation.operationBuffer));

                        case 1:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }));

                return function (_x) {
                  return _ref.apply(this, arguments);
                };
              }()));

            case 17:
              operationModels = _context2.sent;
              createOperations = operationModels.filter(function (operation) {
                return operation.type === common.OperationType.Create;
              });
              recoverOperations = operationModels.filter(function (operation) {
                return operation.type === common.OperationType.Recover;
              });
              updateOperations = operationModels.filter(function (operation) {
                return operation.type === common.OperationType.Update;
              });
              deactivateOperations = operationModels.filter(function (operation) {
                return operation.type === common.OperationType.Deactivate;
              }); // Create the chunk file buffer from the operation models.
              // NOTE: deactivate operations don't have delta.

              _context2.next = 24;
              return ChunkFile.createBuffer(createOperations, recoverOperations, updateOperations);

            case 24:
              chunkFileBuffer = _context2.sent;
              _context2.next = 27;
              return this.cas.write(chunkFileBuffer);

            case 27:
              chunkFileHash = _context2.sent;
              console.info(LogColor.lightBlue("Wrote chunk file " + LogColor.green(chunkFileHash) + " to content addressable store.")); // Write the map file to content addressable store.

              _context2.next = 31;
              return MapFile.createBuffer(chunkFileHash, updateOperations);

            case 31:
              mapFileBuffer = _context2.sent;
              _context2.next = 34;
              return this.cas.write(mapFileBuffer);

            case 34:
              mapFileHash = _context2.sent;
              console.info(LogColor.lightBlue("Wrote map file " + LogColor.green(mapFileHash) + " to content addressable store.")); // Write the anchor file to content addressable store.

              writerLockId = currentLock ? currentLock.identifier : undefined;
              _context2.next = 39;
              return AnchorFile.createBuffer(writerLockId, mapFileHash, createOperations, recoverOperations, deactivateOperations);

            case 39:
              anchorFileBuffer = _context2.sent;
              _context2.next = 42;
              return this.cas.write(anchorFileBuffer);

            case 42:
              anchorFileHash = _context2.sent;
              console.info(LogColor.lightBlue("Wrote anchor file " + LogColor.green(anchorFileHash) + " to content addressable store.")); // Anchor the data to the blockchain

              dataToBeAnchored = {
                anchorFileHash: anchorFileHash,
                numberOfOperations: numberOfOperations
              };
              stringToWriteToBlockchain = common.AnchoredDataSerializer.serialize(dataToBeAnchored);
              fee = FeeManager.computeMinimumTransactionFee(normalizedFee, numberOfOperations);
              console.info(LogColor.lightBlue("Writing data to blockchain: " + LogColor.green(stringToWriteToBlockchain) + " with minimum fee of: " + LogColor.green("" + fee)));
              _context2.next = 50;
              return this.blockchain.write(stringToWriteToBlockchain, fee);

            case 50:
              _context2.next = 52;
              return this.operationQueue.dequeue(queuedOperations.length);

            case 52:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function write() {
      return _write.apply(this, arguments);
    }

    return write;
  }();

  _proto.getNumberOfOperationsAllowed = function getNumberOfOperationsAllowed(valueTimeLock) {
    var maxNumberOfOpsAllowedByProtocol = common.protocolParameters.maxOperationsPerBatch;
    var maxNumberOfOpsAllowedByLock = ValueTimeLockVerifier.calculateMaxNumberOfOperationsAllowed(valueTimeLock, this.versionMetadataFetcher);

    if (maxNumberOfOpsAllowedByLock > maxNumberOfOpsAllowedByProtocol) {
      // tslint:disable-next-line: max-line-length
      console.info("Maximum number of operations allowed by value time lock: " + maxNumberOfOpsAllowedByLock + "; Maximum number of operations allowed by protocol: " + maxNumberOfOpsAllowedByProtocol);
    }

    return Math.min(maxNumberOfOpsAllowedByLock, maxNumberOfOpsAllowedByProtocol);
  };

  return BatchWriter;
}();

/**
 * Implementation of IOperationProcessor.
 */

var OperationProcessor = /*#__PURE__*/function () {
  function OperationProcessor() {}

  var _proto = OperationProcessor.prototype;

  _proto.apply = /*#__PURE__*/function () {
    var _apply = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(anchoredOperationModel, didState) {
      var previousOperationTransactionNumber, appliedDidState, index, time, number, didUniqueSuffix;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(didState === undefined && anchoredOperationModel.type !== common.OperationType.Create)) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", undefined);

            case 2:
              previousOperationTransactionNumber = didState ? didState.lastOperationTransactionNumber : undefined;

              if (!(anchoredOperationModel.type === common.OperationType.Create)) {
                _context.next = 9;
                break;
              }

              _context.next = 6;
              return this.applyCreateOperation(anchoredOperationModel, didState);

            case 6:
              appliedDidState = _context.sent;
              _context.next = 28;
              break;

            case 9:
              if (!(anchoredOperationModel.type === common.OperationType.Update)) {
                _context.next = 15;
                break;
              }

              _context.next = 12;
              return this.applyUpdateOperation(anchoredOperationModel, didState);

            case 12:
              appliedDidState = _context.sent;
              _context.next = 28;
              break;

            case 15:
              if (!(anchoredOperationModel.type === common.OperationType.Recover)) {
                _context.next = 21;
                break;
              }

              _context.next = 18;
              return this.applyRecoverOperation(anchoredOperationModel, didState);

            case 18:
              appliedDidState = _context.sent;
              _context.next = 28;
              break;

            case 21:
              if (!(anchoredOperationModel.type === common.OperationType.Deactivate)) {
                _context.next = 27;
                break;
              }

              _context.next = 24;
              return this.applyDeactivateOperation(anchoredOperationModel, didState);

            case 24:
              appliedDidState = _context.sent;
              _context.next = 28;
              break;

            case 27:
              throw new common.SidetreeError(common.ErrorCode.OperationProcessorUnknownOperationType);

            case 28:
              try {
                // If the operation was not applied, log some info in case needed for debugging.
                if (appliedDidState === undefined || appliedDidState.lastOperationTransactionNumber === previousOperationTransactionNumber) {
                  index = anchoredOperationModel.operationIndex;
                  time = anchoredOperationModel.transactionTime;
                  number = anchoredOperationModel.transactionNumber;
                  didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;
                  console.debug("Ignored invalid operation for DID '" + didUniqueSuffix + "' in transaction '" + number + "' at time '" + time + "' at operation index " + index + ".");
                }
              } catch (error) {
                console.log("Failed logging " + error + "."); // If logging fails, just move on.
              }

              return _context.abrupt("return", appliedDidState);

            case 30:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function apply(_x, _x2) {
      return _apply.apply(this, arguments);
    }

    return apply;
  }();

  _proto.getRevealValue = /*#__PURE__*/function () {
    var _getRevealValue = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(anchoredOperationModel) {
      var operation, revealValueBuffer, recoverOperation, updateOperation, deactivateOperation;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(anchoredOperationModel.type === common.OperationType.Create)) {
                _context2.next = 2;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.OperationProcessorCreateOperationDoesNotHaveRevealValue);

            case 2:
              _context2.next = 4;
              return Operation.parse(anchoredOperationModel.operationBuffer);

            case 4:
              operation = _context2.sent;
              _context2.t0 = operation.type;
              _context2.next = _context2.t0 === common.OperationType.Recover ? 8 : _context2.t0 === common.OperationType.Update ? 11 : 14;
              break;

            case 8:
              recoverOperation = operation;
              revealValueBuffer = common.JsonCanonicalizer.canonicalizeAsBuffer(recoverOperation.signedData.recovery_key);
              return _context2.abrupt("return", revealValueBuffer);

            case 11:
              updateOperation = operation;
              revealValueBuffer = common.JsonCanonicalizer.canonicalizeAsBuffer(updateOperation.signedData.update_key);
              return _context2.abrupt("return", revealValueBuffer);

            case 14:
              // This is a deactivate.
              deactivateOperation = operation;
              revealValueBuffer = common.JsonCanonicalizer.canonicalizeAsBuffer(deactivateOperation.signedData.recovery_key);
              return _context2.abrupt("return", revealValueBuffer);

            case 17:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function getRevealValue(_x3) {
      return _getRevealValue.apply(this, arguments);
    }

    return getRevealValue;
  }()
  /**
   * @returns new DID state if operation is applied successfully; the given DID state otherwise.
   */
  ;

  _proto.applyCreateOperation =
  /*#__PURE__*/
  function () {
    var _applyCreateOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(anchoredOperationModel, didState) {
      var operation, isMatchingDelta, delta, document, didUniqueSuffix, transactionNumber, newDidState;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(didState !== undefined)) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return", didState);

            case 2:
              _context3.next = 4;
              return CreateOperation.parse(anchoredOperationModel.operationBuffer);

            case 4:
              operation = _context3.sent;
              // Ensure actual delta hash matches expected delta hash.
              isMatchingDelta = common.Multihash.isValidHash(operation.encodedDelta, operation.suffixData.delta_hash);

              if (isMatchingDelta) {
                _context3.next = 8;
                break;
              }

              return _context3.abrupt("return", didState);

            case 8:
              // Apply the given patches against an empty object.
              delta = operation.delta;
              document = {};
              _context3.prev = 10;

              if (delta !== undefined) {
                document = DocumentComposer.applyPatches(document, delta.patches);
              }

              _context3.next = 20;
              break;

            case 14:
              _context3.prev = 14;
              _context3.t0 = _context3["catch"](10);
              didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;
              transactionNumber = anchoredOperationModel.transactionNumber;
              console.debug("Unable to apply document patch in transaction number " + transactionNumber + " for DID " + didUniqueSuffix + ": " + common.SidetreeError.stringify(_context3.t0) + "."); // Return the given DID state if error is encountered applying the patches.

              return _context3.abrupt("return", didState);

            case 20:
              newDidState = {
                didUniqueSuffix: operation.didUniqueSuffix,
                document: document,
                nextRecoveryCommitmentHash: operation.suffixData.recovery_commitment,
                nextUpdateCommitmentHash: delta ? delta.update_commitment : undefined,
                lastOperationTransactionNumber: anchoredOperationModel.transactionNumber
              };
              return _context3.abrupt("return", newDidState);

            case 22:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[10, 14]]);
    }));

    function applyCreateOperation(_x4, _x5) {
      return _applyCreateOperation.apply(this, arguments);
    }

    return applyCreateOperation;
  }()
  /**
   * @returns new DID state if operation is applied successfully; the given DID state otherwise.
   */
  ;

  _proto.applyUpdateOperation =
  /*#__PURE__*/
  function () {
    var _applyUpdateOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(anchoredOperationModel, didState) {
      var operation, isValidUpdateKey, signatureIsValid, isValidDelta, resultingDocument, didUniqueSuffix, transactionNumber, newDidState;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return UpdateOperation.parse(anchoredOperationModel.operationBuffer);

            case 2:
              operation = _context4.sent;
              // Verify the update key hash.
              isValidUpdateKey = common.Multihash.canonicalizeAndVerify(operation.signedData.update_key, didState.nextUpdateCommitmentHash);

              if (isValidUpdateKey) {
                _context4.next = 6;
                break;
              }

              return _context4.abrupt("return", didState);

            case 6:
              _context4.next = 8;
              return operation.signedDataJws.verifySignature(operation.signedData.update_key);

            case 8:
              signatureIsValid = _context4.sent;

              if (signatureIsValid) {
                _context4.next = 11;
                break;
              }

              return _context4.abrupt("return", didState);

            case 11:
              // Verify the delta hash against the expected delta hash.
              isValidDelta = common.Multihash.isValidHash(operation.encodedDelta, operation.signedData.delta_hash);

              if (isValidDelta) {
                _context4.next = 14;
                break;
              }

              return _context4.abrupt("return", didState);

            case 14:
              _context4.prev = 14;
              _context4.next = 17;
              return DocumentComposer.applyUpdateOperation(operation, didState.document);

            case 17:
              resultingDocument = _context4.sent;
              _context4.next = 26;
              break;

            case 20:
              _context4.prev = 20;
              _context4.t0 = _context4["catch"](14);
              didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;
              transactionNumber = anchoredOperationModel.transactionNumber;
              console.debug("Unable to apply document patch in transaction number " + transactionNumber + " for DID " + didUniqueSuffix + ": " + common.SidetreeError.stringify(_context4.t0) + "."); // Return the given DID state if error is encountered applying the patches.

              return _context4.abrupt("return", didState);

            case 26:
              newDidState = {
                nextRecoveryCommitmentHash: didState.nextRecoveryCommitmentHash,
                // New values below.
                document: resultingDocument,
                nextUpdateCommitmentHash: operation.delta.update_commitment,
                lastOperationTransactionNumber: anchoredOperationModel.transactionNumber
              };
              return _context4.abrupt("return", newDidState);

            case 28:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, null, [[14, 20]]);
    }));

    function applyUpdateOperation(_x6, _x7) {
      return _applyUpdateOperation.apply(this, arguments);
    }

    return applyUpdateOperation;
  }()
  /**
   * @returns new DID state if operation is applied successfully; the given DID state otherwise.
   */
  ;

  _proto.applyRecoverOperation =
  /*#__PURE__*/
  function () {
    var _applyRecoverOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(anchoredOperationModel, didState) {
      var operation, isValidRecoveryKey, signatureIsValid, isMatchingDelta, delta, document, didUniqueSuffix, transactionNumber, newDidState;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return RecoverOperation.parse(anchoredOperationModel.operationBuffer);

            case 2:
              operation = _context5.sent;
              // Verify the recovery key hash.
              isValidRecoveryKey = common.Multihash.canonicalizeAndVerify(operation.signedData.recovery_key, didState.nextRecoveryCommitmentHash);

              if (isValidRecoveryKey) {
                _context5.next = 6;
                break;
              }

              return _context5.abrupt("return", didState);

            case 6:
              _context5.next = 8;
              return operation.signedDataJws.verifySignature(operation.signedData.recovery_key);

            case 8:
              signatureIsValid = _context5.sent;

              if (signatureIsValid) {
                _context5.next = 11;
                break;
              }

              return _context5.abrupt("return", didState);

            case 11:
              // Verify the actual delta hash against the expected delta hash.
              isMatchingDelta = common.Multihash.isValidHash(operation.encodedDelta, operation.signedData.delta_hash);

              if (isMatchingDelta) {
                _context5.next = 14;
                break;
              }

              return _context5.abrupt("return", didState);

            case 14:
              // Apply the given patches against an empty object.
              delta = operation.delta;
              document = {};
              _context5.prev = 16;

              if (delta !== undefined) {
                document = DocumentComposer.applyPatches(document, delta.patches);
              }

              _context5.next = 26;
              break;

            case 20:
              _context5.prev = 20;
              _context5.t0 = _context5["catch"](16);
              didUniqueSuffix = anchoredOperationModel.didUniqueSuffix;
              transactionNumber = anchoredOperationModel.transactionNumber;
              console.debug("Unable to apply document patch in transaction number " + transactionNumber + " for DID " + didUniqueSuffix + ": " + common.SidetreeError.stringify(_context5.t0) + "."); // Return the given DID state if error is encountered applying the patches.

              return _context5.abrupt("return", didState);

            case 26:
              newDidState = {
                didUniqueSuffix: operation.didUniqueSuffix,
                document: document,
                recovery_key: operation.signedData.recovery_key,
                nextRecoveryCommitmentHash: operation.signedData.recovery_commitment,
                nextUpdateCommitmentHash: delta ? delta.update_commitment : undefined,
                lastOperationTransactionNumber: anchoredOperationModel.transactionNumber
              };
              return _context5.abrupt("return", newDidState);

            case 28:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, null, [[16, 20]]);
    }));

    function applyRecoverOperation(_x8, _x9) {
      return _applyRecoverOperation.apply(this, arguments);
    }

    return applyRecoverOperation;
  }()
  /**
   * @returns new DID state if operation is applied successfully; the given DID state otherwise.
   */
  ;

  _proto.applyDeactivateOperation =
  /*#__PURE__*/
  function () {
    var _applyDeactivateOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(anchoredOperationModel, didState) {
      var operation, isValidRecoveryKey, signatureIsValid, newDidState;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return DeactivateOperation.parse(anchoredOperationModel.operationBuffer);

            case 2:
              operation = _context6.sent;
              // Verify the recovery key hash.
              isValidRecoveryKey = common.Multihash.canonicalizeAndVerify(operation.signedData.recovery_key, didState.nextRecoveryCommitmentHash);

              if (isValidRecoveryKey) {
                _context6.next = 6;
                break;
              }

              return _context6.abrupt("return", didState);

            case 6:
              _context6.next = 8;
              return operation.signedDataJws.verifySignature(operation.signedData.recovery_key);

            case 8:
              signatureIsValid = _context6.sent;

              if (signatureIsValid) {
                _context6.next = 11;
                break;
              }

              return _context6.abrupt("return", didState);

            case 11:
              // The operation passes all checks.
              newDidState = {
                document: didState.document,
                // New values below.
                recovery_key: undefined,
                nextRecoveryCommitmentHash: undefined,
                nextUpdateCommitmentHash: undefined,
                lastOperationTransactionNumber: anchoredOperationModel.transactionNumber
              };
              return _context6.abrupt("return", newDidState);

            case 13:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    function applyDeactivateOperation(_x10, _x11) {
      return _applyDeactivateOperation.apply(this, arguments);
    }

    return applyDeactivateOperation;
  }();

  return OperationProcessor;
}();

/**
 * Class containing reusable Sidetree DID related operations.
 */

var Did = /*#__PURE__*/function () {
  /**
   * Parses the input string as Sidetree DID.
   * NOTE: Must not call this constructor directly, use the factory `create` method instead.
   * @param did Short or long-form DID string.
   * @param didMethodName The expected DID method given in the DID string. The method throws SidetreeError if mismatch.
   */
  function Did(did, didMethodName) {
    this.didMethodName = didMethodName;
    var didPrefix = "did:" + didMethodName + ":";

    if (!did.startsWith(didPrefix)) {
      throw new common.SidetreeError(common.ErrorCode.DidIncorrectPrefix);
    }

    var indexOfQuestionMarkChar = did.indexOf('?'); // If there is no question mark, then DID can only be in short-form.

    if (indexOfQuestionMarkChar < 0) {
      this.isShortForm = true;
    } else {
      this.isShortForm = false;
    }

    if (this.isShortForm) {
      this.uniqueSuffix = did.substring(didPrefix.length);
    } else {
      // This is long-form.
      this.uniqueSuffix = did.substring(didPrefix.length, indexOfQuestionMarkChar);
    }

    if (this.uniqueSuffix.length === 0) {
      throw new common.SidetreeError(common.ErrorCode.DidNoUniqueSuffix);
    }

    this.shortForm = didPrefix + this.uniqueSuffix;
  }
  /**
   * Parses the input string as Sidetree DID.
   * @param didString Short or long-form DID string.
   */


  Did.create =
  /*#__PURE__*/
  function () {
    var _create = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(didString, didMethodName) {
      var did, initialState, createOperation, suffixDataHashMatchesUniqueSuffix;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              did = new Did(didString, didMethodName); // If DID is long-form, ensure the unique suffix constructed from the suffix data matches the short-form DID and populate the `createOperation` property.

              if (did.isShortForm) {
                _context.next = 10;
                break;
              }

              initialState = Did.getInitialStateFromDidString(didString, didMethodName);
              _context.next = 5;
              return Did.constructCreateOperationFromInitialState(initialState);

            case 5:
              createOperation = _context.sent;
              // NOTE: we cannot use the unique suffix directly from `createOperation.didUniqueSuffix` for comparison,
              // becasue a given long-form DID may have been created long ago,
              // thus this version of `CreateOperation.parse()` maybe using a different hashing algorithm than that of the unique DID suffix (short-form).
              // So we compute the suffix data hash again using the hashing algorithm used by the given unique DID suffix (short-form).
              suffixDataHashMatchesUniqueSuffix = common.Multihash.isValidHash(createOperation.encodedSuffixData, did.uniqueSuffix); // If the computed suffix data hash is not the same as the unique suffix given in the DID string, the DID is not valid.

              if (suffixDataHashMatchesUniqueSuffix) {
                _context.next = 9;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.DidUniqueSuffixFromInitialStateMismatch);

            case 9:
              did.createOperation = createOperation;

            case 10:
              return _context.abrupt("return", did);

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function create(_x, _x2) {
      return _create.apply(this, arguments);
    }

    return create;
  }();

  Did.getInitialStateFromDidString = function getInitialStateFromDidString(didString, methodNameWithNetworkId) {
    var didStringUrl = undefined;

    try {
      didStringUrl = new url.URL(didString);
    } catch (_unused) {
      throw new common.SidetreeError(common.ErrorCode.DidInvalidDidString);
    } // TODO: #470 - Support/disambiguate "network ID" in method name.
    // Stripping away the potential network ID portion. e.g. 'sidetree:test' -> 'sidetree'


    var methodName = methodNameWithNetworkId.split(':')[0];
    var queryParamCounter = 0;
    var initialStateValue; // Verify that `-<method-name>-initial-state` is the one and only parameter.

    for (var _iterator = _createForOfIteratorHelperLoose(didStringUrl.searchParams), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          key = _step$value[0],
          value = _step$value[1];
      queryParamCounter += 1;

      if (queryParamCounter > 1) {
        throw new common.SidetreeError(common.ErrorCode.DidLongFormOnlyOneQueryParamAllowed);
      } // expect key to be -<method-name>-initial-state


      var expectedKey = "-" + methodName + "-" + Did.initialStateParameterSuffix;

      if (key !== expectedKey) {
        throw new common.SidetreeError(common.ErrorCode.DidLongFormOnlyInitialStateParameterIsAllowed);
      }

      initialStateValue = value;
    }

    if (initialStateValue === undefined) {
      throw new common.SidetreeError(common.ErrorCode.DidLongFormNoInitialStateFound);
    }

    return initialStateValue;
  };

  Did.constructCreateOperationFromInitialState = /*#__PURE__*/function () {
    var _constructCreateOperationFromInitialState = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(initialState) {
      var firstIndexOfDot, lastIndexOfDot, initialStateParts, suffixData, delta, createOperationRequest, createOperationBuffer, createOperation;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              // Initial state should be in the format: <suffix-data>.<delta>
              firstIndexOfDot = initialState.indexOf('.');

              if (!(firstIndexOfDot === -1)) {
                _context2.next = 3;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.DidInitialStateValueContainsNoDot);

            case 3:
              lastIndexOfDot = initialState.lastIndexOf('.');

              if (!(lastIndexOfDot !== firstIndexOfDot)) {
                _context2.next = 6;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.DidInitialStateValueContainsMoreThanOneDot);

            case 6:
              if (!(firstIndexOfDot === initialState.length - 1 || firstIndexOfDot === 0)) {
                _context2.next = 8;
                break;
              }

              throw new common.SidetreeError(common.ErrorCode.DidInitialStateValueDoesNotContainTwoParts);

            case 8:
              initialStateParts = initialState.split('.');
              suffixData = initialStateParts[0];
              delta = initialStateParts[1];
              createOperationRequest = {
                type: common.OperationType.Create,
                suffix_data: suffixData,
                delta: delta
              };
              createOperationBuffer = Buffer.from(JSON.stringify(createOperationRequest));
              _context2.next = 15;
              return CreateOperation.parseObject(createOperationRequest, createOperationBuffer, false);

            case 15:
              createOperation = _context2.sent;
              return _context2.abrupt("return", createOperation);

            case 17:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function constructCreateOperationFromInitialState(_x3) {
      return _constructCreateOperationFromInitialState.apply(this, arguments);
    }

    return constructCreateOperationFromInitialState;
  }();

  return Did;
}();
Did.initialStateParameterSuffix = 'initial-state';

/**
 * Sidetree operation request handler.
 */

var RequestHandler = /*#__PURE__*/function () {
  function RequestHandler(resolver, operationQueue, didMethodName) {
    this.resolver = resolver;
    this.operationQueue = operationQueue;
    this.didMethodName = didMethodName;
    this.operationProcessor = new OperationProcessor();
  }
  /**
   * Handles an operation request.
   */


  var _proto = RequestHandler.prototype;

  _proto.handleOperationRequest =
  /*#__PURE__*/
  function () {
    var _handleOperationRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(request) {
      var operationModel, operationRequest, deltaBuffer, errorMessage, _errorMessage, response;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              console.info("Handling operation request of size " + request.length + " bytes..."); // Perform common validation for any write request and parse it into an `OperationModel`.

              _context.prev = 1;
              _context.next = 4;
              return JsonAsync.parse(request);

            case 4:
              operationRequest = _context.sent;

              if (!(operationRequest.type === common.OperationType.Create || operationRequest.type === common.OperationType.Recover || operationRequest.type === common.OperationType.Update)) {
                _context.next = 11;
                break;
              }

              deltaBuffer = Buffer.from(operationRequest.delta);

              if (!(deltaBuffer.length > common.protocolParameters.maxDeltaSizeInBytes)) {
                _context.next = 11;
                break;
              }

              errorMessage = "operationDdata byte size of " + deltaBuffer.length + " exceeded limit of " + common.protocolParameters.maxDeltaSizeInBytes;
              console.info(errorMessage);
              throw new common.SidetreeError(common.ErrorCode.RequestHandlerDeltaExceedsMaximumSize, errorMessage);

            case 11:
              _context.next = 13;
              return Operation.parse(request);

            case 13:
              operationModel = _context.sent;
              _context.next = 16;
              return this.operationQueue.contains(operationModel.didUniqueSuffix);

            case 16:
              if (!_context.sent) {
                _context.next = 19;
                break;
              }

              _errorMessage = "An operation request already exists in queue for DID '" + operationModel.didUniqueSuffix + "', only one is allowed at a time.";
              throw new common.SidetreeError(common.ErrorCode.QueueingMultipleOperationsPerDidNotAllowed, _errorMessage);

            case 19:
              _context.next = 29;
              break;

            case 21:
              _context.prev = 21;
              _context.t0 = _context["catch"](1);

              if (!(_context.t0 instanceof common.SidetreeError)) {
                _context.next = 27;
                break;
              }

              console.info("Bad request: " + _context.t0.code);
              console.info("Error message: " + _context.t0.message);
              return _context.abrupt("return", {
                status: common.ResponseStatus.BadRequest,
                body: {
                  code: _context.t0.code,
                  message: _context.t0.message
                }
              });

            case 27:
              // Else we give a generic bad request response.
              console.info("Bad request: " + _context.t0);
              return _context.abrupt("return", {
                status: common.ResponseStatus.BadRequest
              });

            case 29:
              _context.prev = 29;
              console.info("Operation type: '" + operationModel.type + "', DID unique suffix: '" + operationModel.didUniqueSuffix + "'"); // Passed common operation validation, hand off to specific operation handler.

              _context.t1 = operationModel.type;
              _context.next = _context.t1 === common.OperationType.Create ? 34 : _context.t1 === common.OperationType.Update ? 38 : _context.t1 === common.OperationType.Recover ? 38 : _context.t1 === common.OperationType.Deactivate ? 38 : 40;
              break;

            case 34:
              _context.next = 36;
              return this.handleCreateRequest(operationModel);

            case 36:
              response = _context.sent;
              return _context.abrupt("break", 41);

            case 38:
              response = {
                status: common.ResponseStatus.Succeeded
              };
              return _context.abrupt("break", 41);

            case 40:
              // Should be an impossible condition, but we defensively check and handle.
              response = {
                status: common.ResponseStatus.BadRequest,
                body: {
                  code: common.ErrorCode.RequestHandlerUnknownOperationType,
                  message: "Unsupported operation type '" + operationModel.type + "'."
                }
              };

            case 41:
              if (!(response.status === common.ResponseStatus.Succeeded)) {
                _context.next = 44;
                break;
              }

              _context.next = 44;
              return this.operationQueue.enqueue(operationModel.didUniqueSuffix, operationModel.operationBuffer);

            case 44:
              return _context.abrupt("return", response);

            case 47:
              _context.prev = 47;
              _context.t2 = _context["catch"](29);

              if (!(_context.t2 instanceof common.SidetreeError)) {
                _context.next = 52;
                break;
              }

              console.info("Sidetree error: " + _context.t2.code + " " + _context.t2.message);
              return _context.abrupt("return", {
                status: common.ResponseStatus.BadRequest,
                body: {
                  code: _context.t2.code,
                  message: _context.t2.message
                }
              });

            case 52:
              console.info("Unexpected error: " + _context.t2);
              return _context.abrupt("return", {
                status: common.ResponseStatus.ServerError
              });

            case 54:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[1, 21], [29, 47]]);
    }));

    function handleOperationRequest(_x) {
      return _handleOperationRequest.apply(this, arguments);
    }

    return handleOperationRequest;
  }();

  _proto.handleCreateRequest = /*#__PURE__*/function () {
    var _handleCreateRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(operationModel) {
      var didState, did, document;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.applyCreateOperation(operationModel);

            case 2:
              didState = _context2.sent;

              if (!(didState === undefined)) {
                _context2.next = 5;
                break;
              }

              return _context2.abrupt("return", {
                status: common.ResponseStatus.BadRequest,
                body: 'Invalid create operation.'
              });

            case 5:
              did = "did:" + this.didMethodName + ":" + operationModel.didUniqueSuffix;
              document = DocumentComposer.transformToExternalDocument(didState, did);
              return _context2.abrupt("return", {
                status: common.ResponseStatus.Succeeded,
                body: document
              });

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function handleCreateRequest(_x2) {
      return _handleCreateRequest.apply(this, arguments);
    }

    return handleCreateRequest;
  }()
  /**
   * Handles resolve operation.
   * @param shortOrLongFormDid Can either be:
   *   1. A short-form DID. e.g. 'did:<methodName>:abc' or
   *   2. A long-form DID. e.g. 'did:<methodName>:<unique-portion>?-<methodName>-initial-state=<encoded-original-did-document>'.
   */
  ;

  _proto.handleResolveRequest =
  /*#__PURE__*/
  function () {
    var _handleResolveRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(shortOrLongFormDid) {
      var did, didState, document;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              console.info("Handling resolution request for: " + shortOrLongFormDid + "...");
              _context3.next = 4;
              return Did.create(shortOrLongFormDid, this.didMethodName);

            case 4:
              did = _context3.sent;

              if (!did.isShortForm) {
                _context3.next = 11;
                break;
              }

              _context3.next = 8;
              return this.resolver.resolve(did.uniqueSuffix);

            case 8:
              didState = _context3.sent;
              _context3.next = 14;
              break;

            case 11:
              _context3.next = 13;
              return this.resolveLongFormDid(did);

            case 13:
              didState = _context3.sent;

            case 14:
              if (!(didState === undefined)) {
                _context3.next = 16;
                break;
              }

              return _context3.abrupt("return", {
                status: common.ResponseStatus.NotFound
              });

            case 16:
              document = DocumentComposer.transformToExternalDocument(didState, shortOrLongFormDid);
              return _context3.abrupt("return", {
                status: common.ResponseStatus.Succeeded,
                body: document
              });

            case 20:
              _context3.prev = 20;
              _context3.t0 = _context3["catch"](0);

              if (!(_context3.t0 instanceof common.SidetreeError)) {
                _context3.next = 24;
                break;
              }

              return _context3.abrupt("return", {
                status: common.ResponseStatus.BadRequest,
                body: {
                  code: _context3.t0.code,
                  message: _context3.t0.message
                }
              });

            case 24:
              console.info("Unexpected error: " + _context3.t0);
              return _context3.abrupt("return", {
                status: common.ResponseStatus.ServerError
              });

            case 26:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this, [[0, 20]]);
    }));

    function handleResolveRequest(_x3) {
      return _handleResolveRequest.apply(this, arguments);
    }

    return handleResolveRequest;
  }()
  /**
   * Resolves the given long-form DID by resolving using operations found over the network first;
   * if no operations found, the given create operation will is used to construct the DID state.
   */
  ;

  _proto.resolveLongFormDid =
  /*#__PURE__*/
  function () {
    var _resolveLongFormDid = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(did) {
      var didState;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.resolver.resolve(did.uniqueSuffix);

            case 2:
              didState = _context4.sent;

              if (!(didState !== undefined)) {
                _context4.next = 5;
                break;
              }

              return _context4.abrupt("return", didState);

            case 5:
              _context4.next = 7;
              return this.applyCreateOperation(did.createOperation);

            case 7:
              didState = _context4.sent;
              return _context4.abrupt("return", didState);

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function resolveLongFormDid(_x4) {
      return _resolveLongFormDid.apply(this, arguments);
    }

    return resolveLongFormDid;
  }();

  _proto.applyCreateOperation = /*#__PURE__*/function () {
    var _applyCreateOperation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(createOperation) {
      var operationWithMockedAnchorTime, newDidState;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              operationWithMockedAnchorTime = {
                didUniqueSuffix: createOperation.didUniqueSuffix,
                type: common.OperationType.Create,
                transactionTime: 0,
                transactionNumber: 0,
                operationIndex: 0,
                operationBuffer: createOperation.operationBuffer
              }; // NOTE: The transaction timing does not matter here, we are just computing a "theoretical" document if it were anchored on blockchain.

              _context5.next = 3;
              return this.operationProcessor.apply(operationWithMockedAnchorTime, undefined);

            case 3:
              newDidState = _context5.sent;
              return _context5.abrupt("return", newDidState);

            case 5:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function applyCreateOperation(_x5) {
      return _applyCreateOperation.apply(this, arguments);
    }

    return applyCreateOperation;
  }();

  return RequestHandler;
}();

/**
 * Implementation of the abstract VersionMetadata.
 */

var VersionMetadata = /*#__PURE__*/function (_AbstractVersionMetad) {
  _inheritsLoose(VersionMetadata, _AbstractVersionMetad);

  function VersionMetadata() {
    var _this;

    _this = _AbstractVersionMetad.call(this) || this;
    _this.hashAlgorithmInMultihashCode = common.protocolParameters.hashAlgorithmInMultihashCode;
    _this.normalizedFeeToPerOperationFeeMultiplier = common.protocolParameters.normalizedFeeToPerOperationFeeMultiplier;
    _this.valueTimeLockAmountMultiplier = common.protocolParameters.valueTimeLockAmountMultiplier;
    return _this;
  }

  return VersionMetadata;
}(common.AbstractVersionMetadata);

/**
 * The class that handles the loading of different versions of protocol codebase.
 */

var VersionManager = /*#__PURE__*/function () {
  function VersionManager(config, protocolVersions) {
    this.config = config;
    this.allSupportedHashAlgorithms = []; // Reverse sort protocol versions.

    this.protocolVersionsReverseSorted = protocolVersions.sort(function (a, b) {
      return b.startingBlockchainTime - a.startingBlockchainTime;
    });
    this.batchWriters = new Map();
    this.operationProcessors = new Map();
    this.operationQueues = new Map();
    this.requestHandlers = new Map();
    this.transactionProcessors = new Map();
    this.transactionSelectors = new Map();
    this.versionMetadatas = new Map();
  }
  /**
   * Loads all the versions of the protocol codebase.
   */


  var _proto = VersionManager.prototype;

  _proto.initialize =
  /*#__PURE__*/
  function () {
    var _initialize = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(blockchain, cas, downloadManager, operationStore, resolver, transactionStore) {
      var _iterator, _step, protocolVersion, version, _MongoDbOperationQueue, operationQueue, _TransactionProcessor, transactionProcessor, _TransactionSelector, transactionSelector, _BatchWriter, batchWriter, _OperationProcessor, operationProcessor, _RequestHandler, requestHandler, _VersionMetadata, versionMetadata, hashAlgorithmsWithDuplicates;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iterator = _createForOfIteratorHelperLoose(this.protocolVersionsReverseSorted);

            case 1:
              if ((_step = _iterator()).done) {
                _context.next = 45;
                break;
              }

              protocolVersion = _step.value;
              version = protocolVersion.version;
              /* tslint:disable-next-line */

              _context.next = 6;
              return this.loadDefaultExportsForVersion(version, 'MongoDbOperationQueue');

            case 6:
              _MongoDbOperationQueue = _context.sent;
              operationQueue = new _MongoDbOperationQueue(this.config.mongoDbConnectionString, this.config.databaseName);
              _context.next = 10;
              return operationQueue.initialize();

            case 10:
              this.operationQueues.set(version, operationQueue);
              /* tslint:disable-next-line */

              _context.next = 13;
              return this.loadDefaultExportsForVersion(version, 'TransactionProcessor');

            case 13:
              _TransactionProcessor = _context.sent;
              transactionProcessor = new _TransactionProcessor(downloadManager, operationStore, blockchain, this);
              this.transactionProcessors.set(version, transactionProcessor);
              /* tslint:disable-next-line */

              _context.next = 18;
              return this.loadDefaultExportsForVersion(version, 'TransactionSelector');

            case 18:
              _TransactionSelector = _context.sent;
              transactionSelector = new _TransactionSelector(transactionStore);
              this.transactionSelectors.set(version, transactionSelector);
              /* tslint:disable-next-line */

              _context.next = 23;
              return this.loadDefaultExportsForVersion(version, 'BatchWriter');

            case 23:
              _BatchWriter = _context.sent;
              batchWriter = new _BatchWriter(operationQueue, blockchain, cas, this);
              this.batchWriters.set(version, batchWriter);
              /* tslint:disable-next-line */

              _context.next = 28;
              return this.loadDefaultExportsForVersion(version, 'OperationProcessor');

            case 28:
              _OperationProcessor = _context.sent;
              operationProcessor = new _OperationProcessor();
              this.operationProcessors.set(version, operationProcessor);
              /* tslint:disable-next-line */

              _context.next = 33;
              return this.loadDefaultExportsForVersion(version, 'RequestHandler');

            case 33:
              _RequestHandler = _context.sent;
              requestHandler = new _RequestHandler(resolver, operationQueue, this.config.didMethodName);
              this.requestHandlers.set(version, requestHandler);
              /* tslint:disable-next-line */

              _context.next = 38;
              return this.loadDefaultExportsForVersion(version, 'VersionMetadata');

            case 38:
              _VersionMetadata = _context.sent;
              versionMetadata = new _VersionMetadata();

              if (versionMetadata instanceof common.AbstractVersionMetadata) {
                _context.next = 42;
                break;
              }

              throw new common.SidetreeError(common.CoreErrorCode.VersionManagerVersionMetadataIncorrectType, "make sure VersionMetaData is properly implemented for version " + version);

            case 42:
              this.versionMetadatas.set(version, versionMetadata);

            case 43:
              _context.next = 1;
              break;

            case 45:
              // Get and cache supported hash algorithms.
              hashAlgorithmsWithDuplicates = Array.from(this.versionMetadatas.values(), function (value) {
                return value.hashAlgorithmInMultihashCode;
              });
              this.allSupportedHashAlgorithms = Array.from(new Set(hashAlgorithmsWithDuplicates)); // This line removes duplicates.

            case 47:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function initialize(_x, _x2, _x3, _x4, _x5, _x6) {
      return _initialize.apply(this, arguments);
    }

    return initialize;
  }()
  /**
   * Gets the corresponding version of the `IBatchWriter` based on the given blockchain time.
   */
  ;

  _proto.getBatchWriter = function getBatchWriter(blockchainTime) {
    var version = this.getVersionString(blockchainTime);
    var batchWriter = this.batchWriters.get(version);

    if (batchWriter === undefined) {
      throw new common.SidetreeError(common.CoreErrorCode.VersionManagerBatchWriterNotFound, "Batch writer for blockchain time " + blockchainTime + " not found.");
    }

    return batchWriter;
  }
  /**
   * Gets the corresponding version of the `IOperationProcessor` based on the given blockchain time.
   */
  ;

  _proto.getOperationProcessor = function getOperationProcessor(blockchainTime) {
    var version = this.getVersionString(blockchainTime);
    var operationProcessor = this.operationProcessors.get(version);

    if (operationProcessor === undefined) {
      throw new common.SidetreeError(common.CoreErrorCode.VersionManagerOperationProcessorNotFound, "Operation processor for blockchain time " + blockchainTime + " not found.");
    }

    return operationProcessor;
  }
  /**
   * Gets the corresponding version of the `IRequestHandler` based on the given blockchain time.
   */
  ;

  _proto.getRequestHandler = function getRequestHandler(blockchainTime) {
    var version = this.getVersionString(blockchainTime);
    var requestHandler = this.requestHandlers.get(version);

    if (requestHandler === undefined) {
      throw new common.SidetreeError(common.CoreErrorCode.VersionManagerRequestHandlerNotFound, "Request handler for blockchain time " + blockchainTime + " not found.");
    }

    return requestHandler;
  }
  /**
   * Gets the corresponding version of the `TransactionProcessor` based on the given blockchain time.
   */
  ;

  _proto.getTransactionProcessor = function getTransactionProcessor(blockchainTime) {
    var version = this.getVersionString(blockchainTime);
    var transactionProcessor = this.transactionProcessors.get(version);

    if (transactionProcessor === undefined) {
      throw new common.SidetreeError(common.CoreErrorCode.VersionManagerTransactionProcessorNotFound, "Transaction processor for blockchain time " + blockchainTime + " not found.");
    }

    return transactionProcessor;
  }
  /**
   * Gets the corresponding version of the `TransactionSelector` based on the given blockchain time.
   */
  ;

  _proto.getTransactionSelector = function getTransactionSelector(blockchainTime) {
    var version = this.getVersionString(blockchainTime);
    var transactionSelector = this.transactionSelectors.get(version);

    if (transactionSelector === undefined) {
      throw new common.SidetreeError(common.CoreErrorCode.VersionManagerTransactionSelectorNotFound, "Transaction selector for blockchain time " + blockchainTime + " not found.");
    }

    return transactionSelector;
  };

  _proto.getVersionMetadata = function getVersionMetadata(blockchainTime) {
    var versionString = this.getVersionString(blockchainTime);
    var versionMetadata = this.versionMetadatas.get(versionString); // this is always be defined because if blockchain time is found, version will be defined

    return versionMetadata;
  };

  _proto.getOperationQueue = function getOperationQueue(blockchainTime) {
    var versionString = this.getVersionString(blockchainTime);
    var operationQueue = this.operationQueues.get(versionString); // this is always be defined because if blockchain time is found, version will be defined

    return operationQueue;
  }
  /**
   * Gets the corresponding protocol version string given the blockchain time.
   */
  ;

  _proto.getVersionString = function getVersionString(blockchainTime) {
    // Iterate through each version to find the right version.
    for (var _iterator2 = _createForOfIteratorHelperLoose(this.protocolVersionsReverseSorted), _step2; !(_step2 = _iterator2()).done;) {
      var protocolVersion = _step2.value;

      if (blockchainTime >= protocolVersion.startingBlockchainTime) {
        return protocolVersion.version;
      }
    }

    throw new common.SidetreeError(common.CoreErrorCode.VersionManagerVersionStringNotFound, "Unable to find version string for blockchain time " + blockchainTime + ".");
  };

  _proto.loadDefaultExportsForVersion = /*#__PURE__*/function () {
    var _loadDefaultExportsForVersion = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(version, className) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(version === 'latest')) {
                _context2.next = 12;
                break;
              }

              _context2.t0 = className;
              _context2.next = _context2.t0 === 'MongoDbOperationQueue' ? 4 : _context2.t0 === 'TransactionProcessor' ? 5 : _context2.t0 === 'TransactionSelector' ? 6 : _context2.t0 === 'BatchWriter' ? 7 : _context2.t0 === 'OperationProcessor' ? 8 : _context2.t0 === 'RequestHandler' ? 9 : _context2.t0 === 'VersionMetadata' ? 10 : 11;
              break;

            case 4:
              return _context2.abrupt("return", db.MongoDbOperationQueue);

            case 5:
              return _context2.abrupt("return", TransactionProcessor);

            case 6:
              return _context2.abrupt("return", TransactionSelector);

            case 7:
              return _context2.abrupt("return", BatchWriter);

            case 8:
              return _context2.abrupt("return", OperationProcessor);

            case 9:
              return _context2.abrupt("return", RequestHandler);

            case 10:
              return _context2.abrupt("return", VersionMetadata);

            case 11:
              return _context2.abrupt("return");

            case 12:
              _context2.next = 14;
              return new Promise(function (resolve) { resolve(_interopNamespace(require("./versions/" + version + "/" + className))); });

            case 14:
              return _context2.abrupt("return", _context2.sent["default"]);

            case 15:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function loadDefaultExportsForVersion(_x7, _x8) {
      return _loadDefaultExportsForVersion.apply(this, arguments);
    }

    return loadDefaultExportsForVersion;
  }();

  return VersionManager;
}();

exports.AnchorFile = AnchorFile;
exports.BatchScheduler = BatchScheduler;
exports.ChunkFile = ChunkFile;
exports.Compressor = Compressor;
exports.CreateOperation = CreateOperation;
exports.DeactivateOperation = DeactivateOperation;
exports.DownloadManager = DownloadManager;
exports.JsonAsync = JsonAsync;
exports.Jwk = Jwk;
exports.Jws = Jws;
exports.MapFile = MapFile;
exports.Observer = Observer;
exports.Operation = Operation;
exports.OperationGenerator = OperationGenerator;
exports.RecoverOperation = RecoverOperation;
exports.Resolver = Resolver;
exports.ServiceInfo = ServiceInfoProvider;
exports.TransactionProcessor = TransactionProcessor;
exports.UpdateOperation = UpdateOperation;
exports.VersionManager = VersionManager;
//# sourceMappingURL=core.cjs.development.js.map
