import { Sync } from 'factory.ts';
import { Cipher } from 'minimal-cipher';
import crypto from 'isomorphic-webcrypto';
import { X25519KeyPair } from '@transmute/did-key-x25519';
import { Ed25519KeyPair, driver } from '@transmute/did-key-ed25519';

var WalletStatus;

(function (WalletStatus) {
  WalletStatus["Locked"] = "LOCKED";
  WalletStatus["Unlocked"] = "UNLOCKED";
})(WalletStatus || (WalletStatus = {}));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// A type of promise-like that resolves synchronously and supports only one observer
const _Pact = /*#__PURE__*/(function() {
	function _Pact() {}
	_Pact.prototype.then = function(onFulfilled, onRejected) {
		const result = new _Pact();
		const state = this.s;
		if (state) {
			const callback = state & 1 ? onFulfilled : onRejected;
			if (callback) {
				try {
					_settle(result, 1, callback(this.v));
				} catch (e) {
					_settle(result, 2, e);
				}
				return result;
			} else {
				return this;
			}
		}
		this.o = function(_this) {
			try {
				const value = _this.v;
				if (_this.s & 1) {
					_settle(result, 1, onFulfilled ? onFulfilled(value) : value);
				} else if (onRejected) {
					_settle(result, 1, onRejected(value));
				} else {
					_settle(result, 2, value);
				}
			} catch (e) {
				_settle(result, 2, e);
			}
		};
		return result;
	};
	return _Pact;
})();

// Settles a pact synchronously
function _settle(pact, state, value) {
	if (!pact.s) {
		if (value instanceof _Pact) {
			if (value.s) {
				if (state & 1) {
					state = value.s;
				}
				value = value.v;
			} else {
				value.o = _settle.bind(null, pact, state);
				return;
			}
		}
		if (value && value.then) {
			value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
			return;
		}
		pact.s = state;
		pact.v = value;
		const observer = pact.o;
		if (observer) {
			observer(pact);
		}
	}
}

function _isSettledPact(thenable) {
	return thenable instanceof _Pact && thenable.s & 1;
}

// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)
function _forTo(array, body, check) {
	var i = -1, pact, reject;
	function _cycle(result) {
		try {
			while (++i < array.length && (!check || !check())) {
				result = body(i);
				if (result && result.then) {
					if (_isSettledPact(result)) {
						result = result.v;
					} else {
						result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
						return;
					}
				}
			}
			if (pact) {
				_settle(pact, 1, result);
			} else {
				pact = result;
			}
		} catch (e) {
			_settle(pact || (pact = new _Pact()), 2, e);
		}
	}
	_cycle();
	return pact;
}

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

var seedToId = function seedToId(seed) {
  try {
    return Promise.resolve(crypto.subtle.digest('SHA-256', seed)).then(function (buffer) {
      return "urn:digest:" + Buffer.from(new Int8Array(buffer)).toString('hex');
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var passwordToKey = function passwordToKey(password, salt, iterations, digest) {
  if (salt === void 0) {
    salt = 'salt';
  }

  if (iterations === void 0) {
    iterations = 100000;
  }

  if (digest === void 0) {
    digest = 'SHA-256';
  }

  try {
    var saltBuffer = Buffer.from(salt);
    var passphraseKey = Buffer.from(password);
    return Promise.resolve(crypto.subtle.importKey('raw', passphraseKey, {
      name: 'PBKDF2'
    }, false, ['deriveBits', 'deriveKey']).then(function (key) {
      return crypto.subtle.deriveKey({
        name: 'PBKDF2',
        salt: saltBuffer,
        iterations: iterations,
        hash: digest
      }, key, // Note: we don't actually need a cipher suite,
      // but the api requires that it must be specified.
      // For AES the length required to be 128 or 256 bits (not bytes)
      {
        name: 'AES-CBC',
        length: 256
      }, // Whether or not the key is extractable (less secure) or not (more secure)
      // when false, the key can only be passed as a web crypto object, not inspected
      true, // this web crypto object will only be allowed for these functions
      ['encrypt', 'decrypt']);
    }).then(function (webKey) {
      return crypto.subtle.exportKey('raw', webKey);
    }).then(function (buffer) {
      return new Uint8Array(buffer);
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};
var unlockDidKey = function unlockDidKey(seed) {
  try {
    return Promise.resolve(Ed25519KeyPair.generate({
      secureRandom: function secureRandom() {
        return seed;
      }
    })).then(function (ed25519Key) {
      return Promise.resolve(driver.resolve(ed25519Key.controller)).then(function (result) {
        var unlockedDIDDocument = _extends({}, result.didDocument);

        var x25519Key = ed25519Key.toX25519KeyPair(true);
        unlockedDIDDocument.verificationMethod[0].privateKeyBase58 = ed25519Key.toKeyPair(true).privateKeyBase58;
        unlockedDIDDocument.verificationMethod[1].privateKeyBase58 = x25519Key.toKeyPair(true).privateKeyBase58;
        return unlockedDIDDocument;
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var lockDidKey = function lockDidKey(unlockedDIDDocument) {
  delete unlockedDIDDocument.verificationMethod[0].privateKeyBase58;
  delete unlockedDIDDocument.verificationMethod[1].privateKeyBase58;

  var didDocument = _extends({}, unlockedDIDDocument);

  return didDocument;
};
var getKeyResolver = function getKeyResolver(didDocument) {
  var keyAgreementKey = didDocument.verificationMethod[1];

  var keyResolver = function keyResolver(_ref) {
    var id = _ref.id;

    if (keyAgreementKey.id === id) {
      return keyAgreementKey;
    }

    throw new Error("Key " + id + " not found in " + didDocument.id);
  };

  return keyResolver;
};
var lockContent = function lockContent(_ref2) {
  var content = _ref2.content,
      cipher = _ref2.cipher,
      recipients = _ref2.recipients,
      keyResolver = _ref2.keyResolver;

  try {
    return Promise.resolve(cipher.encryptObject({
      obj: content,
      recipients: recipients,
      keyResolver: keyResolver
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};
var unlockContent = function unlockContent(_ref3) {
  var content = _ref3.content,
      cipher = _ref3.cipher,
      keyAgreementKey = _ref3.keyAgreementKey;

  try {
    return Promise.resolve(cipher.decryptObject({
      jwe: content,
      keyAgreementKey: new X25519KeyPair(keyAgreementKey)
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};
var lockContents = function lockContents(password, contents) {
  try {
    return Promise.resolve(passwordToKey(password)).then(function (derivedKey) {
      return Promise.resolve(unlockDidKey(derivedKey)).then(function (unlockedDidKey) {
        var lockedDidKey = lockDidKey(unlockedDidKey);
        var keyAgreementKey = lockedDidKey.verificationMethod[1];

        if (keyAgreementKey.id.indexOf('#') === 0) {
          keyAgreementKey.id = keyAgreementKey.controller + keyAgreementKey.id;
        }

        var recipient = {
          header: {
            kid: keyAgreementKey.id,
            alg: 'ECDH-ES+A256KW'
          }
        };
        var recipients = [recipient];
        var keyResolver = getKeyResolver(lockedDidKey);
        var cipher = new Cipher();
        return Promise.all(contents.map(function (content) {
          return lockContent({
            content: _extends({}, content),
            cipher: cipher,
            recipients: [].concat(recipients),
            keyResolver: keyResolver
          });
        }));
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var unlockContents = function unlockContents(password, contents) {
  try {
    return Promise.resolve(passwordToKey(password)).then(function (derivedKey) {
      return Promise.resolve(unlockDidKey(derivedKey)).then(function (unlockedDidKey) {
        var keyAgreementKey = unlockedDidKey.verificationMethod[1];

        if (keyAgreementKey.id.indexOf('#') === 0) {
          keyAgreementKey.id = keyAgreementKey.controller + keyAgreementKey.id;
        }

        var cipher = new Cipher();
        var decryptedContents = [];

        var _temp = _forTo(contents, function (i) {
          var content = contents[i];
          return Promise.resolve(unlockContent({
            content: content,
            cipher: cipher,
            keyAgreementKey: keyAgreementKey
          })).then(function (decryptedContent) {
            decryptedContents.push(decryptedContent);
          });
        });

        return _temp && _temp.then ? _temp.then(function () {
          return decryptedContents;
        }) : decryptedContents;
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var walletDefaults = {
  status: WalletStatus.Unlocked,
  contents: [],
  passwordToKey: passwordToKey,
  seedToId: seedToId,
  add: function add(content) {
    this.contents.push(content);
    return this;
  },
  remove: function remove(contentId) {
    var contents = JSON.parse(JSON.stringify(this.contents));
    var index = contents.findIndex(function (c) {
      return c.id === contentId;
    });
    var content = contents[index];
    this.contents = contents.filter(function (i) {
      return i.id !== content.id;
    });
    return content;
  },
  lock: function lock(password) {
    try {
      var _this2 = this;

      return Promise.resolve(lockContents(password, _this2.contents)).then(function (_lockContents) {
        _this2.contents = _lockContents;
        _this2.status = WalletStatus.Locked;
        return _this2;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  },
  unlock: function unlock(password) {
    try {
      var _this4 = this;

      return Promise.resolve(unlockContents(password, _this4.contents)).then(function (_unlockContents) {
        _this4.contents = _unlockContents;
        _this4.status = WalletStatus.Unlocked;
        return _this4;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  },
  "export": function _export(password) {
    try {
      var _this6 = this;

      return Promise.resolve(passwordToKey(password)).then(function (seed) {
        return Promise.resolve(unlockDidKey(seed)).then(function (didDoc) {
          // we don't want to leak number of wallet contents...
          // so we push them into a single object before encrypting.
          return Promise.resolve(lockContents(password, [{
            contents: _this6.contents
          }])).then(function (lockedContents) {
            var encryptedWallet = {
              '@context': ['https://www.w3.org/2018/credentials/v1', 'http://w3id.org/wallet/v1'],
              // consider using content id of ciphertext here...
              id: didDoc.id + '#encrypted-wallet',
              type: ['VerifiableCredential', 'EncryptedWallet'],
              issuer: didDoc.id,
              issuanceDate: new Date().toISOString(),
              credentialSubject: {
                id: didDoc.id,
                encryptedWalletContents: lockedContents[0]
              }
            };
            return encryptedWallet;
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  },
  "import": function _import(encryptedWalletCredential, password) {
    try {
      var _this8 = this;

      if (_this8.contents.length) {
        throw new Error('Cannot import over existing wallet content.');
      }

      return Promise.resolve(unlockContents(password, [encryptedWalletCredential.credentialSubject.encryptedWalletContents])).then(function (unlockedContents) {
        _this8.contents = unlockedContents[0].contents;
        _this8.status = WalletStatus.Unlocked;
        return _this8;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  },
  query: function query(map, reduce, initialValue) {
    if (this.status !== WalletStatus.Unlocked) {
      throw new Error('You can only query an unlocked wallet.');
    }

    var results = this.contents.map(map);

    if (reduce) {
      return results.reduce(reduce, initialValue);
    }

    return results;
  }
};
var walletFactory = /*#__PURE__*/Sync.makeFactory(walletDefaults);

export { getKeyResolver, lockContent, lockContents, lockDidKey, passwordToKey, seedToId, unlockContent, unlockContents, unlockDidKey, walletDefaults, walletFactory };
//# sourceMappingURL=universal-wallet.esm.js.map
